# 3. Загрузка системы

## 3.1. Цепочка загрузки (Boot Chain)

KyroOS использует современный загрузчик [Limine](https://github.com/limine-bootloader/limine), который поддерживает как устаревшие системы с BIOS, так и современные с UEFI. Процесс загрузки состоит из нескольких последовательных этапов, передающих управление от прошивки компьютера ядру операционной системы.

**Общая последовательность:**

1.  **Прошивка (BIOS/UEFI):** Выполняет инициализацию базового оборудования (Power-On Self-Test, POST) и, согласно своим настройкам, находит загрузочный сектор на загрузочном носителе (например, ISO-образе).
2.  **Загрузчик Limine:** Прошивка передает управление загрузчику Limine. Limine сканирует файловую систему носителя, находит и читает конфигурационный файл `limine.conf`.
3.  **Загрузка ядра:** Следуя инструкциям из `limine.conf`, Limine загружает в оперативную память основной файл ядра (`/boot/kernel.elf`) и указанные в конфигурации файлы-модули (например, утилиты пользовательского пространства).
4.  **Передача управления ядру:** Limine подготавливает окружение (устанавливает 64-битный режим, формирует карту памяти и т.д.) и передает управление на точку входа ядра, определенную в ELF-файле.

## 3.2. Этапы загрузки ядра

Процесс инициализации самого ядра делится на два основных этапа: низкоуровневая подготовка на ассемблере и высокоуровневая инициализация подсистем на языке C.

### Этап 1: Низкоуровневая инициализация (`_start` в `src/boot/boot.asm`)

Сразу после получения управления от Limine, процессор начинает выполнение кода с метки `_start`. На этом этапе выполняются критически важные первоначальные действия:

1.  **Отключение прерываний:** Первой же инструкцией является `cli`. Это предотвращает возникновение любых аппаратных прерываний, пока система не будет готова их обрабатывать (т.е. пока не будет настроена IDT и обработчики).
2.  **Установка стека:** Настраивается указатель стека (`rsp`) на предварительно выделенную в BSS-секции область памяти. Это необходимо для корректной работы вызовов функций.
3.  **Вызов C-кода:** Выполняется инструкция `call kmain_x64`, которая передает управление основной функции инициализации ядра, написанной на C.

На этом работа ассемблерного кода завершается. Его единственная задача — создать минимально необходимое окружение для запуска C-функций.

### Этап 2: Высокоуровневая инициализация (`kmain_x64` в `src/kernel/kernel.c`)

Функция `kmain_x64` является точкой входа в высокоуровневую часть ядра и выполняет последовательную инициализацию всех ключевых подсистем. Порядок инициализации строго определен и критически важен для корректного запуска системы.

1.  **Инициализация логирования (`log_init`):** Запускается подсистема логирования, позволяющая выводить отладочную информацию через последовательный порт.
2.  **Инициализация Framebuffer (`fb_init`):** На основе информации, полученной от Limine, настраивается видео-буфер для вывода графики и текста на экран.
3.  **Инициализация управления памятью:**
    *   **PMM (`pmm_init`):** Инициализируется менеджер физической памяти, который получает карту доступной памяти от Limine и создает структуру для учета свободных и занятых страниц.
    *   **Heap (`heap_init`):** На основе PMM создается ядровая куча для динамического выделения памяти (`kmalloc`, `kfree`).
    *   **VMM (`vmm_init`):** Инициализируется менеджер виртуальной памяти. Создаются и загружаются таблицы страниц (PML4) для адресного пространства ядра.
4.  **Настройка структур процессора:**
    *   **GDT (`gdt_init`):** Загружается новая Global Descriptor Table, содержащая сегменты для кода и данных ядра и пользовательского пространства.
    *   **IDT (`idt_init`):** Загружается Interrupt Descriptor Table с обработчиками исключений процессора и аппаратных прерываний.
    *   **TSS (`tss_init`):** Инициализируется Task State Segment, используемый для переключений стека при смене уровня привилегий.
5.  **Инициализация базовых драйверов:**
    *   **Клавиатура (`keyboard_init`):** Настраивается драйвер для обработки ввода с клавиатуры.
    *   **Таймер (`timer_init`):** Программируется прерывание от системного таймера (обычно с частотой 100 Гц), которое будет использоваться планировщиком.
6.  **Инициализация файловой системы:**
    *   **VFS (`vfs_init`):** Запускается слой виртуальной файловой системы, предоставляющий унифицированный API для работы с файлами.
    *   **KyroFS (`kyrofs_init`):** Инициализируется и монтируется корневая файловая система (in-memory).
    *   **Загрузка модулей:** Файлы, загруженные Limine как модули, с помощью VFS помещаются в файловую систему KyroFS (например, в директорию `/bin/`).
7.  **Инициализация устройств и драйверов:**
    *   **Device Manager (`deviceman_init`):** Запускается менеджер устройств.
    *   **PCI (`pci_check_all_buses`):** Производится сканирование шины PCI для обнаружения подключенных устройств.
    *   **Сетевой стек:** Последовательно инициализируются все уровни сетевого стека (E1000, ARP, IP, UDP, TCP, DHCP).
8.  **Запуск многозадачности:**
    *   **Потоки (`thread_init`):** Инициализируется подсистема управления потоками.
    *   Создается первый поток ядра, который начинает выполнение основной функции пользовательской оболочки (`shell_main`).
9.  **Включение прерываний:** Выполняется инструкция `sti`. С этого момента система становится полностью интерактивной: процессор начинает реагировать на прерывания от таймера (запуская планировщик) и устройств ввода.

После выполнения `sti`, функция `kmain_x64` фактически завершает свою работу, и управление системой полностью переходит к планировщику и обработчикам прерываний.
# 16. Сборка и разработка

KyroOS использует стандартные инструменты GNU для сборки, ориентированные на кросс-компиляцию для архитектуры x86-64.

## 16.1. Инструменты сборки

Для сборки KyroOS требуется следующий набор инструментов:
-   **Кросс-компилятор GCC (GNU Compiler Collection):** `x86_64-linux-gnu-gcc` — основной компилятор для C-кода ядра и пользовательских приложений.
-   **NASM (Netwide Assembler):** Ассемблер для обработки низкоуровневых ассемблерных файлов (`.asm`).
-   **GNU Binutils:** Включает в себя архиватор (`x86_64-linux-gnu-ar`) для создания статических библиотек и компоновщик (`x86_64-linux-gnu-ld`) для линковки ELF-файлов.
-   **xorriso:** Инструмент для создания загрузочных ISO-образов.
-   **GNU Make:** Система автоматизации сборки, управляемая файлом `Makefile`.
-   **Среда сборки:** Оптимизирована для работы в Linux или Windows Subsystem for Linux (WSL).

## 16.2. Структура исходников

Проект имеет следующую ключевую структуру каталогов:

-   `src/`: Корневой каталог для всего исходного кода KyroOS.
    -   `src/boot/`: Низкоуровневые ассемблерные файлы (загрузка, переключение контекста, заглушки прерываний).
    -   `src/include/`: Общие заголовочные файлы для ядра и пользовательского пространства (API, определения структур).
    -   `src/kernel/`: Основные компоненты ядра (управление памятью, планировщик, драйверы, системные вызовы, сетевой стек).
    -   `src/tools/`: Исходный код системных утилит пользовательского пространства (coreutils, kpm, installer).
-   `userspace/`: Исходный код пользовательского пространства.
    -   `userspace/lib/`: Статические библиотеки пользовательского режима (упрощенная libc, графическая библиотека `kyroos_gfx`, текстовый UI `tui`).
    -   `userspace/game/`: Пример пользовательского приложения.
    -   `userspace/init/`: Программа `init`, запускаемая при старте ОС.
-   `modules/`: Исходный код загружаемых модулей ядра (LKM).
    -   `modules/hello_lkm/`: Пример простого LKM.
-   `limine/`: Исходный код загрузчика Limine (часто используется как подмодуль Git).
-   `build/`: Каталог для всех сгенерированных файлов: объектных файлов (`.o`), статических библиотек (`.a`), исполняемых файлов (`.elf`).
-   `doc/` и `docs/`: Документация проекта.

## 16.3. Процесс сборки

Основная цель `all` в `Makefile` выполняет полную сборку системы:
1.  Компилируется весь C-код ядра с использованием `x86_64-linux-gnu-gcc` и ассемблерный код с `nasm`.
2.  Создается статическая библиотека ядра (`libkyroos_kernel.a`) из объектных файлов.
3.  Ядро компонуется (`x86_64-linux-gnu-ld`) в исполняемый файл `kyroos.elf`, используя `linker.ld`.
4.  Компилируются пользовательские библиотеки и приложения.
5.  Создается загружаемый ISO-образ (`kyroos.iso`) с помощью `xorriso`, содержащий ядро, загрузчик Limine и все пользовательские исполняемые файлы.

### Флаги компиляции

-   **Флаги ядра (`K_CFLAGS`):**
    -   `-ffreestanding`, `-nostdlib`: Указывают на отсутствие стандартной библиотеки C.
    -   `-fno-stack-protector`, `-fno-stack-check`: Отключают защиту стека.
    -   `-mcmodel=kernel`: Специальная модель памяти для ядра.
    -   `-mno-red-zone`: Отключает "красную зону" стека, важную для безопасности прерываний.
    -   `-m64`, `-march=x86-64`, `-mabi=sysv`: Целевая архитектура x86-64, 64-битный режим, ABI System V.
    -   `-O2`: Уровень оптимизации.
    -   `-Wall`, `-Wextra`: Включение всех предупреждений компилятора.
-   **Флаги пользовательского пространства (`U_CFLAGS`):** Аналогичны флагам ядра, но могут включать другие опции, например, `-std=gnu11` для поддержки расширений GNU C.

## 16.4. Debug / Release конфигурации

На данный момент в системе **отсутствуют явные цели или переменные в `Makefile` для переключения между отладочной (`Debug`) и релизной (`Release`) конфигурациями** сборки.
-   **Оптимизация:** Флаги компиляции (`-O2`) по умолчанию указывают на сборку с оптимизацией, характерной для релизных версий.
-   **Отладочные символы:** Отладочные символы (`-g`) не включаются по умолчанию, что также типично для релизных сборок.
-   **Флаг `epstein`:** В коде ядра существует программный флаг `epstein` (см. `src/kernel/epstein.h`), который позволяет активировать некоторые функции отладки (например, ручное инициирование паники) на уровне кода. Его состояние должно управляться вручную (например, через `#define` в заголовочном файле).
Для выполнения отладки в QEMU (`make run`) необходимо вручную подключить GDB.
# 15. Отладка и логирование

Для обеспечения стабильности, диагностики ошибок и разработки в KyroOS предусмотрены различные механизмы отладки и логирования.

## 15.1. Debug-интерфейсы

### Последовательный порт (Serial Port)

Основным низкоуровневым интерфейсом для отладки является последовательный порт (COM1).
-   **Ранняя инициализация:** Функции `serial_init()`, `serial_print()` и `serial_print_hex()` позволяют выводить сообщения на последовательный порт на очень ранних этапах загрузки ядра, еще до того, как будут доступны графические подсистемы или полная система логирования.
-   **Постоянный вывод:** Все сообщения системы логирования (`klog`) дублируются на последовательный порт. Это критически важно для анализа проблем, когда основной экран не работает или недоступен.

### Отладчик QEMU (GDB)

KyroOS активно разрабатывается и тестируется в виртуальной среде QEMU. QEMU предоставляет мощные возможности для отладки ядра:
-   **GDB-интеграция:** При запуске QEMU с флагами `-s -S` (например, `qemu-system-x86_64 -cdrom kyroos.iso -serial stdio -s -S`) QEMU открывает GDB-сервер.
-   **Удаленная отладка:** К этому серверу можно подключиться с помощью GNU Debugger (GDB) для пошагового выполнения кода ядра, установки точек останова, просмотра регистров и памяти. Это незаменимый инструмент для низкоуровневой отладки.

### Флаг `epstein` (Режим отладки)

В режиме отладочных сборок (Debug builds) существует флаг `epstein` (см. `src/kernel/epstein.h`), который может быть установлен в 1.
-   **Возможности:** Активация этого флага может предоставлять дополнительные функции для отладки, например, команду `panic <reason>` в системной оболочке, позволяющую искусственно инициировать Kernel Panic для тестирования обработчика.
-   **Ограничения:** Этот флаг **не должен быть активирован** в производственных сборках, так как может создавать уязвимости или нестабильность.

## 15.2. Логирование

Ядро KyroOS предоставляет централизованную систему логирования через функцию `klog()`.

### `klog()`

-   **Уровни логирования:** `klog()` поддерживает различные уровни важности сообщений (`LOG_DEBUG`, `LOG_INFO`, `LOG_WARN`, `LOG_ERROR`, `LOG_PANIC`), что позволяет фильтровать вывод.
-   **Форматированный вывод:** Поддерживает синтаксис, аналогичный `printf`, для удобства форматирования сообщений.
-   **Выходные потоки:** Сообщения `klog()` выводятся одновременно в три потока:
    1.  **Последовательный порт:** Для удаленной отладки и постоянной записи.
    2.  **Framebuffer-консоль:** На экране компьютера отображается текстовая консоль с сообщениями ядра, поддерживающая прокрутку.
    3.  **История в памяти:** Последние 10 сообщений сохраняются в циклическом буфере (`log_history`) в памяти ядра.

### Framebuffer-консоль

Функции (`klog_putchar`, `klog_print_str`, `console_clear`) предоставляют текстовую консоль на графическом Framebuffer. Она поддерживает базовые возможности:
-   Вывод символов и строк.
-   Перенос строк.
-   Прокрутка при заполнении экрана.

## 15.3. Crash-диагностика

KyroOS включает специализированный механизм для диагностики критических сбоев ядра, известный как Kernel Panic.

-   **Функция `panic()`:** Является центральной точкой для обработки всех невосстановимых ошибок ядра.
    -   При ее вызове сначала выводится краткое сообщение в последовательный порт.
    -   Затем вызывается `panic_screen_show()`, которая берет на себя управление графическим выводом.
-   **Экран Kernel Panic:** Этот специализированный графический экран предоставляет исчерпывающую информацию о состоянии системы в момент сбоя (подробно описано в **[17. Kernel Panic и критические ошибки ядра](./kernel_panics.md)**):
    -   **Сообщение о панике:** Передается в `panic()` и отображается крупным планом.
    -   **Дамп регистров:** Отображает значения всех основных регистров CPU в момент паники.
    -   **Трассировка стека:** Восстанавливает последовательность вызовов функций, предшествовавших сбою.
    -   **Информация о Page Fault:** Для исключений Page Fault декодируется код ошибки, и отображается адрес, вызвавший сбой.
    -   **Системная информация:** Версия ОС, данные о CPU, памяти.
    -   **История логов:** На экран выводятся последние 10 сообщений, сохраненных в `log_history`, что позволяет увидеть события, непосредственно предшествовавшие сбою.

Все эти меры позволяют разработчику получить максимально полную картину произошедшего, что значительно упрощает процесс отладки.
# 10. Драйверная модель

KyroOS использует гибридную драйверную модель, сочетающую в себе динамическое обнаружение для современных шин и статическую инициализацию для устаревшего оборудования.

## 10.1. Архитектура драйверов

В основе современной части драйверной модели лежат три компонента:
-   **Device (`device_t`):** Структура, представляющая одно аппаратное устройство, обнаруженное в системе. Содержит идентификационную информацию (например, Vendor/Device ID для PCI-устройств), а также указатель на привязанный к нему драйвер.
-   **Driver (`driver_t`):** Структура, представляющая драйвер. Содержит имя драйвера и указатели на ключевые функции:
    -   `probe()`: Проверяет, может ли данный драйвер работать с указанным устройством.
    -   `attach()`: Инициализирует устройство и "привязывает" к нему драйвер.
    -   `detach()`: Освобождает ресурсы и отключает устройство.
-   **Device Manager (`deviceman`):** Центральный компонент, который выступает в роли реестра. Он хранит список всех зарегистрированных в системе драйверов и список всех обнаруженных устройств.

## 10.2. Инициализация устройств

Процесс инициализации для современных PCI-устройств проходит в несколько этапов:

1.  **Обнаружение (Discovery):** На этапе загрузки ядра вызывается функция `pci_check_all_buses()`, которая сканирует шину PCI. Для каждого найденного устройства она создает структуру `device_t` и регистрирует ее в Device Manager с помощью `deviceman_register_device()`.
2.  **Регистрация драйверов:** Каждый драйвер для PCI-устройств (например, `e1000.c`) имеет функцию инициализации (`e1000_driver_init()`), которая вызывается из `kmain`. Эта функция регистрирует сам драйвер (его структуру `driver_t`) в Device Manager через `deviceman_register_driver()`.
3.  **Сопоставление (Probe/Attach):** После того как все устройства обнаружены и все драйверы зарегистрированы, вызывается функция `deviceman_probe_devices()`. Она выполняет следующую логику:
    -   Для каждого устройства из списка обнаруженных...
    -   ...она перебирает все драйверы из списка зарегистрированных.
    -   Вызывается `driver->probe(device)`. Если функция возвращает `true` (драйвер подходит),...
    -   ...то вызывается `driver->attach(device)`. Если `attach` завершается успешно, устройство и драйвер связываются, и процесс переходит к следующему устройству.

### Инициализация устаревших устройств

Для не-обнаруживаемого оборудования, такого как PS/2 клавиатура или системный таймер (PIT), используется более простая статическая модель. Их функции инициализации (например, `keyboard_init()`) вызываются напрямую из `kmain`. Эти функции вручную настраивают порты ввода-вывода и регистрируют свои обработчики прерываний для соответствующих номеров IRQ.

## 10.3. Поддерживаемые шины

-   **PCI (Peripheral Component Interconnect):** Основная шина для обнаружения и настройки современных устройств, таких как сетевые карты и дисковые контроллеры. Ядро содержит полноценный PCI-сканер.
-   **ISA (Legacy):** Устаревшие устройства, такие как клавиатура, мышь и таймер, управляются напрямую через порты ввода-вывода (I/O Ports).

## 10.4. Взаимодействие с ядром

Драйверы являются неотъемлемой частью ядра и взаимодействуют с другими подсистемами различными способами:

-   **Регистрация в Device Manager:** Как описано выше, это основной способ для PCI-драйверов заявить о себе.
-   **Регистрация обработчиков прерываний:** Драйверы вызывают `register_irq_handler()` для привязки своей функции к определенному IRQ. Эта функция будет вызываться каждый раз при возникновении аппаратного прерывания от устройства.
-   **Выделение памяти:** Драйверы используют `kmalloc()` для выделения памяти под свои внутренние структуры и `pmm_alloc_page()` для выделения страниц под DMA-буферы.
-   **Взаимодействие с VFS:** Драйверы блочных устройств (например, IDE) могут предоставлять свои функции `read`, `write`, `ioctl` и регистрировать `vfs_node_t` в файловой системе (например, `/dev/hda`). Это позволяет пользовательскому пространству взаимодействовать с устройством через стандартные файловые операции.
-   **Взаимодействие с сетевым стеком:** Сетевые драйверы (например, `e1000`) регистрируют себя в сетевой подсистеме (`net_register_device()`), предоставляя функцию для отправки пакетов. При получении пакета обработчик прерывания драйвера передает данные вверх по сетевому стеку (например, в обработчик IP или ARP).
-   **Очередь событий:** Драйверы устройств ввода (клавиатура, мышь) не взаимодействуют с VFS напрямую. Вместо этого они генерируют события (`event_t`) и помещают их в глобальную очередь событий, откуда их могут читать приложения через системный вызов `SYS_INPUT_POLL_EVENT`.
# 9. Файловая система

Файловая система (ФС) в KyroOS имеет двухуровневую архитектуру, состоящую из абстрактного слоя VFS и конкретных реализаций ФС. На данный момент в системе сосуществуют две реализации: современная, иерархическая ФС в памяти (`KyroFS`) и устаревшая, плоская дисковая ФС (`fs_disk`).

## 9.1. Архитектура VFS (Virtual File System)

VFS — это абстрактный слой, который предоставляет единый интерфейс для работы с файлами и директориями для всех компонентов ядра и пользовательского пространства. Он позволяет поддерживать несколько разных файловых систем, скрывая детали их реализации.

### `vfs_node_t`

Центральной структурой VFS является `vfs_node_t` (аналог `inode` в Unix). Эта структура представляет любой объект в файловой иерархии (файл или директорию) и содержит:
-   Базовые метаданные: имя, флаги, размер.
-   Набор **указателей на функции** (`read`, `write`, `open`, `finddir` и т.д.).

Именно через эти указатели реализуется абстракция. Когда ядро вызывает, например, `vfs_read()`, VFS просто передает вызов функции `read`, указанной в `vfs_node_t` данного файла. Эта функция-обработчик предоставляется конкретным драйвером ФС, которому принадлежит файл.

### Регистрация и монтирование

-   **Регистрация:** Драйверы файловых систем могут регистрироваться в VFS при инициализации ядра, сообщая свое имя (например, "kyrofs") и функцию монтирования.
-   **Монтирование:** Системный вызов `mount` позволяет "прикрепить" новую файловую систему (например, с дискового раздела) к существующей директории в дереве VFS. VFS находит нужный драйвер по имени и вызывает его функцию монтирования, которая подготавливает ФС к работе и связывает ее с VFS.

## 9.2. Реализации файловых систем

### KyroFS (In-Memory Filesystem)

KyroFS — это простая, иерархическая файловая система, которая полностью работает в оперативной памяти.
-   **Назначение:** Используется как **корневая файловая система (`/`)**. При загрузке она наполняется системными директориями (`/bin`, `/etc`) и исполняемыми файлами, предварительно загруженными загрузчиком Limine.
-   **Структура:**
    -   **Директории:** Представлены как связный список `vfs_node_t`, где каждый узел списка — это файл или поддиректория.
    -   **Файлы:** Содержимое каждого файла хранится в динамически выделяемом буфере в куче ядра. При записи данных, если буфер переполняется, он перераспределяется с большим размером.
-   **Преимущества и недостатки:**
    -   **(+)** Очень высокая скорость работы, так как нет обращений к диску.
    -   **(-)** Не является персистентной: все изменения теряются при перезагрузке.

### fs_disk (On-Disk Filesystem)

`fs_disk` — это очень простая, **плоская (flat)** файловая система для дисковых разделов.
-   **Архитектура:** На данный момент **не интегрирована с VFS**. Представляет собой устаревшую реализацию с собственным API (`fs_create_file`, `fs_read_file`), которая не использует `vfs_node_t`.
-   **Структура на диске:**
    -   **Блок 0:** Суперблок с сигнатурой "KYRO" и базовой информацией о геометрии ФС.
    -   **Блоки 1..N:** Таблица файлов — непрерывный массив записей `fs_file_entry_t`.
    -   **Остальные блоки:** Область данных.
-   **Ограничения:**
    -   **Плоская структура:** Отсутствует поддержка директорий. Все файлы находятся в одном корневом пространстве.
    -   **Аллокация:** Используется примитивный счетчик "следующего свободного блока". Освобожденные блоки не переиспользуются. Файлы должны занимать непрерывные блоки, что ведет к сильной внешней фрагментации.
    -   **Максимум 32 файла** на всю ФС.

## 9.3. Метаданные

-   **VFS (`struct stat`):** VFS предоставляет стандартную структуру `stat`, содержащую основную информацию о файле: размер (`st_size`), режим (`st_mode` — тип файла) и номер inode (`st_ino`).
-   **KyroFS:** Метаданные хранятся непосредственно в структурах `vfs_node_t` в оперативной памяти.
-   **fs_disk (`fs_file_entry_t`):** Метаданные хранятся в таблице файлов на диске и включают имя файла, его размер, флаги и номер стартового блока данных.

## 9.4. Кэширование

-   **KyroFS:** Концепция кэширования неприменима, так как ФС уже находится в памяти.
-   **fs_disk:** Реализован **кэш таблицы файлов**. При монтировании вся таблица файлов считывается с диска в память. Все операции по созданию/удалению файлов производятся с этой копией в памяти. Обновленная таблица записывается обратно на диск только при размонтировании. **Кэширование блоков данных отсутствует**, все операции чтения и записи файлов идут напрямую на диск.

## 9.5. Права доступа

На данный момент в KyroOS **не реализована** полноценная модель прав доступа (чтение/запись/выполнение для пользователя/группы/остальных). Единственное различие, которое делает система — это тип файла (обычный файл или директория), информация о котором хранится во флаге `st_mode`.
# 19. Планы развития

KyroOS находится в активной стадии развития. Представленные ниже планы отражают наиболее актуальные направления для расширения функциональности, улучшения производительности и повышения стабильности системы. Эти планы основаны на текущих архитектурных компромиссах и выявленных ограничениях.

## 19.1. Расширение архитектуры ядра

### Многозадачность и синхронизация

-   **Реализация примитивов синхронизации:** Внедрение спинлоков, мьютексов и семафоров для обеспечения потокобезопасности и предотвращения состояния гонки в многопоточной среде.
-   **Полноценный механизм блокировки/пробуждения:** Разработка robust-механизма для перевода потоков в состояние ожидания и их последующего пробуждения по событиям (например, завершение I/O, доступность данных в буфере).
-   **Поддержка многоядерных процессоров (Symmetric Multiprocessing, SMP):** Адаптация ядра для работы на многоядерных системах, включая переработку механизмов синхронизации и планирования.

### Управление памятью

-   **Улучшение аллокации `fs_disk`:** Внедрение битмапа свободных блоков для `fs_disk` для эффективного переиспользования освобожденного дискового пространства и снижения фрагментации.
-   **Оптимизация `KyroFS`:** Реализация более эффективных стратегий выделения и перераспределения памяти для файлов в `KyroFS`, например, с использованием аллокации блоков или механизма копирования при записи (copy-on-write).

### Файловая система

-   **Интеграция `fs_disk` с VFS:** Адаптация `fs_disk` для использования через интерфейс VFS, что позволит монтировать ее в иерархию файловой системы.
-   **Иерархическая структура `fs_disk`:** Добавление поддержки директорий в `fs_disk` для создания полноценной файловой иерархии.
-   **Модель прав доступа:** Разработка и внедрение системы прав доступа (пользователь, группа, другие; чтение, запись, выполнение) для файлов и директорий на уровне VFS и конкретных реализаций ФС.
-   **Кэширование данных `fs_disk`:** Реализация буферного кэша для блоков данных `fs_disk` с стратегиями вытеснения (например, LRU) для повышения производительности дисковых операций.
-   **Поддержка других файловых систем:** Добавление драйверов для широко используемых файловых систем, таких как FAT32 или ext2/3/4.

### Сетевой стек

-   **Декомпозиция сетевого ядра:** Отделение общего сетевого ядра (`net_init`, `net_register_device`) от специфических драйверов (например, E1000) для повышения модульности и упрощения добавления новых сетевых драйверов.
-   **Завершение реализации TCP:** Доработка стека TCP для полной поддержки всех состояний, механизмов восстановления, управления окном и контрольных сумм.
-   **Добавление новых сетевых драйверов:** Внедрение драйверов для других популярных сетевых адаптеров (например, VirtIO Net, Realtek RTL8139).

### Графическая подсистема

-   **Разработка оконной системы пользовательского пространства:** Создание полноценной пользовательской библиотеки для отрисовки окон, виджетов и управления композицией на базе прямого доступа к framebuffer.
-   **Поддержка аппаратного ускорения GPU:** (Долгосрочная перспектива) Исследование и интеграция драйверов для графических процессоров с поддержкой аппаратного ускорения отрисовки.

## 19.2. Расширение возможностей пользовательского пространства

### Полнофункциональный менеджер пакетов KyroOS (KPM)
-   **Разработка KPM:** Доработка менеджера пакетов KPM до полнофункционального состояния, включающего:
    -   **Разрешение зависимостей:** Автоматическое определение и установка необходимых для пакета зависимостей.
    -   **Установка и удаление пакетов:** Надежные механизмы инсталляции, обновления и деинсталляции программного обеспечения.
    -   **Интеграция с репозиториями:** Возможность работы с удаленными или локальными репозиториями пакетов.
    -   **Формат пакетов:** Документирование и стандартизация формата `.kpkg` (KyroOS Package) с учетом метаданных, контрольных сумм и структуры.

-   **Полноценная `libc`:** Разработка или портирование более полной стандартной библиотеки C, предоставляющей не только обертки для системных вызовов, но и более широкий набор стандартных функций.
-   **Динамическая компоновка:** Внедрение поддержки динамических библиотек (shared libraries), что позволит уменьшить размер исполняемых файлов и упростит обновление компонентов.
-   **Улучшенная оболочка:** Развитие системной оболочки (`kyroshell`) с поддержкой истории команд, автодополнения, алиасов и скриптов.
-   **Дополнительные утилиты:** Разработка и интеграция более широкого набора стандартных Unix-подобных утилит (например, `grep`, `sed`, `awk`).

## 19.3. Улучшение системной стабильности и отладки

-   **Расширенная обработка ошибок:** Пересмотр текущей стратегии обработки ошибок в ядре с целью уменьшения количества Kernel Panic в случаях, когда возможно более мягкое восстановление (например, завершение проблемного процесса вместо паники всего ядра).
-   **Механизмы Crash Dump:** Реализация сохранения полного состояния ядра (дампа памяти) при Kernel Panic для последующего анализа офлайн-отладчиком.
-   **Инструменты профилирования и мониторинга:** Разработка инструментов для измерения производительности и выявления "узких мест" в ядре и приложениях.
-   **Тестирование:** Внедрение юнит-тестов и интеграционных тестов для ключевых компонентов ядра.
# 11. Графическая подсистема

Графическая подсистема в KyroOS спроектирована по простой и прямой модели, предоставляющей пользовательским приложениям непосредственный доступ к оборудованию. В ядре отсутствуют сложные компоненты, такие как графический сервер или композитор окон.

## 11.1. Framebuffer и модель доступа

Основой всей графической подсистемы является **линейный framebuffer**.

### Инициализация

При загрузке ядро получает от загрузчика Limine информацию о видеорежиме, установленном прошивкой. Эта информация включает в себя:
-   Физический адрес начала framebuffer.
-   Разрешение экрана (ширина и высота в пикселях).
-   `pitch` (количество байт в одной строке экрана).
-   Глубину цвета (`bpp` - bits per pixel).

На основе этих данных инициализируется низкоуровневый драйвер `fb.c`.

### Двойная буферизация

Для предотвращения мерцания и разрывов изображения (`tearing`) при отрисовке, драйвер `fb.c` реализует **двойную буферизацию**:
1.  При инициализации в памяти ядра создается теневой буфер (`backbuffer`) того же размера, что и видимый framebuffer.
2.  Все низкоуровневые операции отрисовки (`fb_put_pixel`, `fb_draw_rect`, `fb_draw_char`) производятся в этом теневом буфере.
3.  После завершения формирования кадра вызывается функция `fb_flush()`, которая атомарно копирует все содержимое `backbuffer` в видимый framebuffer.

### Модель доступа для пользовательского пространства

KyroOS не использует модель клиент-сервер (как X11) для графики. Вместо этого она предоставляет пользовательским приложениям **прямой доступ к видеопамяти**:
1.  Приложение вызывает системный вызов `SYS_GFX_GET_FB_INFO`.
2.  В ответ ядро отображает физические страницы видимого framebuffer напрямую в виртуальное адресное пространство вызывающего процесса.
3.  Приложению возвращаются разрешение экрана и виртуальный адрес, по которому теперь доступен framebuffer.
4.  С этого момента приложение может рисовать что угодно, просто записывая данные в этот участок своей памяти.

**Преимущества:**
-   Максимальная производительность, так как отсутствуют посредники и переключения контекста при отрисовке.

**Недостатки:**
-   Отсутствие защиты: любое приложение может испортить любую часть экрана.
-   Вся логика отрисовки виджетов, управления окнами и их композиции должна быть реализована в библиотеках пользовательского пространства.

### Ускорение GPU

На данный момент **аппаратное ускорение GPU не используется**. Все операции отрисовки выполняются программно центральным процессором.

## 11.2. Оконная система

В KyroOS **отсутствует оконная система (windowing system) на уровне ядра**. Ядро не имеет понятий "окно", "виджет" или "рабочий стол".

### Внутренний GUI-тулкит

В коде ядра (`gui.c`) присутствует рудиментарный графический инструментарий. Он позволяет создавать простые окна и отрисовывать их. Однако этот компонент **недоступен из пользовательского пространства** и используется исключительно для внутренних нужд ядра (например, для отладочных экранов или будущих TUI-инсталляторов, работающих в режиме ядра).

## 11.3. Устройства ввода

Взаимодействие с устройствами ввода полностью отделено от процесса отрисовки.
1.  **Драйверы:** Драйверы клавиатуры и мыши являются обработчиками прерываний (IRQ).
2.  **Очередь событий:** При получении данных от устройства (нажатие клавиши, движение мыши) драйвер не рисует ничего на экране. Вместо этого он формирует структуру `event_t` и помещает ее в глобальную, централизованную **очередь событий**.
3.  **Опрос из Userspace:** Графические приложения в своем цикле работы периодически вызывают системный вызов `SYS_INPUT_POLL_EVENT`, чтобы извлечь следующее событие из очереди.
4.  **Реакция:** Получив событие (например, `EVENT_MOUSE_MOVE`), приложение само решает, как на него реагировать (например, перерисовать курсор в новом месте).
# 6. Прерывания и исключения

Архитектура обработки прерываний и исключений в KyroOS является основой для взаимодействия с оборудованием, обработки ошибок и реализации многозадачности. Она построена на основе Interrupt Descriptor Table (IDT) архитектуры x86-64.

## 6.1. Архитектура обработки

Процесс обработки прерывания или исключения проходит в несколько этапов, от аппаратного события до вызова высокоуровневого C-кода.

1.  **Событие:** Процессор (при возникновении исключения) или внешнее устройство (через контроллер прерываний PIC) инициирует прерывание.
2.  **Поиск в IDT:** Процессор использует номер вектора прерывания (0-255) как индекс в таблице IDT, чтобы найти соответствующий дескриптор шлюза (Gate Descriptor).
3.  **Переход к обработчику-заглушке:** Дескриптор указывает на низкоуровневый обработчик-заглушку (`ISR stub`) на ассемблере. В KyroOS для каждого вектора существует своя уникальная заглушка (`isr0`, `irq0` и т.д.).
4.  **Сохранение контекста:** Ассемблерная заглушка немедленно сохраняет на стеке полный контекст прерванного потока: все регистры общего назначения, а также `RIP`, `CS`, `RFLAGS`, `RSP`, `SS` (последние сохраняются процессором автоматически). Сохраненные данные формируют структуру `struct registers`.
5.  **Вызов C-диспетчера:** Заглушка вызывает общую C-функцию `isr_handler()`, передавая ей указатель на сохраненный на стеке контекст (`struct registers*`).
6.  **Высокоуровневая обработка:** C-диспетчер анализирует номер прерывания и передает управление соответствующему обработчику (например, драйверу клавиатуры или планировщику).
7.  **Возврат:** После завершения работы C-обработчика управление возвращается в ассемблерную заглушку, которая восстанавливает все сохраненные регистры и выполняет инструкцию `iretq`. Эта инструкция атомарно восстанавливает `RIP`, `CS`, `RFLAGS` и другие регистры, возвращая управление в прерванный код.

### Настройка IDT (`idt_init`)

В процессе инициализации ядра функция `idt_init` создает и загружает IDT:
-   Для каждого из 256 векторов создается дескриптор.
-   **Векторы 0-31** связываются с обработчиками **исключений CPU**.
-   **Векторы 32-47** связываются с обработчиками **аппаратных прерываний (IRQ)** от контроллера PIC.
-   **Вектор 128 (0x80)** связывается с обработчиком **системных вызовов**.
-   Для шлюзов ядра используется Interrupt Gate (тип `0x8E`), а для системных вызовов — Trap Gate (тип `0xEE`), который позволяет вызывать прерывание из пользовательского пространства (Ring 3).

### Диспетчеризация IRQ

Для аппаратных прерываний (клавиатура, мышь, диски) используется механизм регистрации. Драйверы могут зарегистрировать свою функцию-обработчик для конкретного номера IRQ с помощью `register_irq_handler()`. Когда C-диспетчер `isr_handler` получает IRQ, он находит и вызывает соответствующий зарегистрированный обработчик.

## 6.2. Таймеры

Системный таймер является ключевым компонентом для реализации вытесняющей многозадачности.
-   **Устройство:** KyroOS использует стандартный Programmable Interval Timer (PIT).
-   **Инициализация (`timer_init`):** Ядро программирует PIT на генерацию прерывания **IRQ 0** с частотой **100 Гц**.
-   **Обработка:** Обработчик IRQ 0 инкрементирует глобальный счетчик тиков (`ticks`) и, что самое важное, вызывает функцию `schedule()`. Именно этот периодический вызов планировщика обеспечивает переключение задач и иллюзию параллельного выполнения.

## 6.3. Исключения CPU

Исключения — это события, генерируемые процессором при обнаружении ошибочной ситуации. В KyroOS обработка исключений, возникших в режиме ядра, реализована максимально безопасно: любая такая ошибка считается фатальной и приводит к **Kernel Panic**.

Диспетчер `isr_handler` для векторов 0-31:
1.  Определяет тип исключения по его номеру.
2.  Находит соответствующее текстовое описание (например, "Page Fault", "General Protection Fault").
3.  Вызывает функцию `panic()`, передавая ей это описание и полный дамп регистров (`struct registers*`), сохраненный на стеке.

Этот подход не пытается восстановить систему после сбоя ядра, а вместо этого обеспечивает максимально полную диагностическую информацию для отладки.

## 6.4. Fault и Trap

В архитектуре x86-64 прерывания и исключения делятся на несколько типов. KyroOS использует два из них:

-   **Fault (Ошибка):** Это тип исключения, о котором сообщается *до* выполнения инструкции, вызвавшей ошибку. Адрес возврата (`RIP`), сохраняемый на стеке, указывает на саму ошибочную инструкцию. Это позволяет обработчику потенциально исправить причину (например, подгрузить страницу при Page Fault) и выполнить инструкцию заново. Исключения Page Fault и General Protection Fault являются примерами Fault.

-   **Trap (Ловушка):** Это тип исключения, о котором сообщается *после* выполнения инструкции. Адрес возврата указывает на инструкцию, *следующую* за той, что вызвала Trap. Это используется для отладки (прерывания по `int3`) и системных вызовов. В KyroOS системные вызовы через `int 0x80` реализованы как Trap, что позволяет программе пользователя продолжить выполнение после того, как ядро завершит свою работу.
# 8. IPC и синхронизация

## 8.1. Механизмы IPC

Inter-Process Communication (IPC) в KyroOS находится на начальном этапе развития. На данный момент реализован один основной механизм.

### 8.1.1. Sockets (Сокеты)

Сокеты являются основным средством межпроцессного взаимодействия в KyroOS. Реализация сетевого стека, включающая TCP и UDP, позволяет процессам обмениваться данными как по сети, так и локально через интерфейс loopback. Это стандартный и гибкий механизм, позволяющий реализовать клиент-серверные архитектуры.

### 8.1.2. Shared Memory (Разделяемая память)

**Assumed Design:** В системе отсутствует явный API для создания сегментов разделяемой памяти (как, например, `shm_open` в POSIX). Однако архитектура VMM позволяет реализовать этот механизм. Потоки, принадлежащие одному логическому процессу (т.е. использующие одно и то же адресное пространство `pml4`), по умолчанию разделяют всю память, что является формой неявной разделяемой памяти.

### 8.1.3. Pipes (Каналы)

Каналы (`pipes`) в данный момент **не реализованы**. Их добавление планируется в будущих версиях.

## 8.2. Примитивы синхронизации

На текущем этапе разработки в KyroOS отсутствуют высокоуровневые примитивы синхронизации, такие как мьютексы, семафоры или спинлоки.

### 8.2.1. Отключение прерываний

Единственным используемым механизмом синхронизации внутри ядра является глобальное отключение и включение прерываний (`disable_interrupts()` / `enable_interrupts()`).

- **Применение:** Этот метод используется для защиты критических секций очень малой длины, где необходимо обеспечить атомарность операций относительно аппаратных прерываний. Примерами являются модификация очередей планировщика или общей событийной очереди.
- **Ограничения:**
    - Это очень "тяжелый" и грубый механизм, который останавливает всю активность в системе, включая тики таймера.
    - Он **не решает проблему синхронизации на многоядерных системах** (которые в данный момент не поддерживаются), так как `cli` действует только на том ядре, где была вызвана.
    - Данный механизм не может использоваться для длительного ожидания ресурса, так как это полностью "замораживает" систему.

### 8.2.2. Блокировка потоков

**Assumed Design:** Состояние потока `THREAD_BLOCKED` существует, и планировщик умеет его обрабатывать (он не выбирает заблокированные потоки для выполнения). Однако, судя по комментариям в коде (`TODO: proper thread blocking/unblocking`), полноценный механизм, который бы переводил поток в состояние `BLOCKED` при ожидании ресурса и пробуждал (`READY`) при его освобождении, еще **не реализован**.

## 8.3. Модель, управляемая событиями

В ядре KyroOS реализована простая модель, управляемая событиями, которая используется преимущественно для обработки ввода.

### событийная очередь (`Event Queue`)

- **Архитектура:** Реализована как глобальная, статическая **кольцевая очередь (circular buffer)** фиксированного размера (256 событий).
- **Структура события (`event_t`):** Каждое событие содержит тип (`EVENT_KEY_DOWN`, `EVENT_MOUSE_MOVE` и т.д.) и до трех целочисленных полей с данными (например, скан-код клавиши или координаты мыши).
- **Производители (Producers):** Обработчики прерываний от устройств ввода (клавиатуры, мыши) являются производителями событий. При получении данных от устройства они формируют `event_t` и помещают его в хвост очереди с помощью `event_push()`.
- **Потребители (Consumers):** Пользовательские приложения являются потребителями. Они могут запрашивать события из головы очереди с помощью системного вызова `SYS_INPUT_POLL_EVENT`, который внутри ядра вызывает `event_pop()`.
- **Синхронизация:** Доступ к очереди (изменение указателей `head`/`tail` и счетчика `event_count`) защищен через `disable_interrupts()`, что обеспечивает потокобезопасность в контексте одноядерной системы.
# Kernel Panic

## 1. Определение

**Kernel Panic** — это механизм обработки критических ошибок в ядре KyroOS. Данное состояние возникает при обнаружении невосстановимой ошибки, которая ставит под угрозу целостность системы и данных. Когда ядро входит в состояние паники, оно немедленно прекращает нормальное выполнение всех процессов, сохраняет максимальный объем диагностической информации для последующего анализа и останавливает систему, чтобы предотвратить дальнейшие повреждения.

Основная цель механизма — не восстановление работы, а безопасная остановка с предоставлением исчерпывающей информации для отладки.

## 2. Классификация причин

Причины, приводящие к Kernel Panic, делятся на две основные категории:

### 2.1. Исключения процессора (CPU Exceptions)
Наиболее частая причина. Ядро KyroOS перехватывает и обрабатывает исключения, генерируемые CPU. Если исключение происходит в режиме ядра (Ring 0) и не может быть безопасно обработано, инициируется паника.

- **Page Fault (PF, #14):** Попытка доступа к невалидной, отсутствующей или защищенной странице памяти в контексте ядра.
- **General Protection Fault (GPF, #13):** Общее нарушение защиты. Примеры: запись в read-only сегмент кода, выполнение привилегированных инструкций из пользовательского режима (хотя это вызовет панику только при ошибке в ядре), неверные селекторы сегментов.
- **Double Fault (#8) / Triple Fault:** Возникают при невозможности CPU вызвать обработчик для предыдущего исключения. Triple Fault является фатальным на уровне архитектуры и приводит к сбросу системы, но Double Fault перехватывается ядром и вызывает панику.
- **Invalid Opcode (UD, #6):** Попытка выполнения некорректной или привилегированной инструкции.
- **Division by Zero (DE, #0):** Целочисленное деление на ноль.

### 2.2. Программные проверки (Software Assertions)
Ядро содержит внутренние проверки целостности (assertions) для верификации инвариантов и критических условий во время выполнения. Если проверка проваливается, это указывает на логическую ошибку в коде ядра.

- **Kernel Assertions:** `ASSERT(condition)` макросы, которые вызывают панику, если `condition` ложно. Например, проверка валидности указателя перед его использованием.
- **Драйверные ошибки:** Критические ошибки в драйверах устройств (например, отказ оборудования, который не может быть обработан).
- **Повреждение структур данных ядра:** Обнаружение повреждений в ключевых структурах, таких как таблицы процессов, аллокаторы памяти или системные списки.
- **Ошибки инициализации:** Невозможность инициализировать критически важный компонент системы во время загрузки.

## 3. Механизм обнаружения

Обнаружение критических ошибок реализовано на двух уровнях:

1.  **Аппаратный уровень:** Настройка таблиц прерываний (IDT). Для каждого исключения CPU, которое считается критическим для ядра, соответствующий шлюз в IDT настроен на вызов общего обработчика исключений. Этот обработчик сохраняет состояние процессора и вызывает процедуру паники.
2.  **Программный уровень:** Явные вызовы функции `panic()` из кода ядра. Эта функция вызывается в местах, где программная логика обнаруживает фатальное состояние, например, при неудачной проверке `ASSERT` или при невозможности аллоцировать критически важный ресурс.

## 4. Процедура обработки

При обнаружении критической ошибки запускается следующая последовательность действий, реализованная в функции `panic_screen_show()` (`src/kernel/panic_screen.c`):

1.  **Остановка прерываний:** Выполняется инструкция `cli`, чтобы предотвратить любые другие прерывания, которые могут помешать обработке паники или усугубить нестабильность системы.
2.  **Инициализация видеорежима:** Экран очищается и заливается красным цветом (`#FF0000`), сигнализируя о критической ошибке. Все последующие текстовые данные выводятся на этом фоне. Если framebuffer недоступен, система просто останавливается (`hlt`).
3.  **Вывод основной информации:** На экран выводится заголовок `!!! KERNEL PANIC !!!` и основное сообщение об ошибке, переданное в функцию `panic()`.
4.  **Сбор и вывод диагностической информации:** Система собирает и отображает максимально подробную информацию о своем состоянии в момент сбоя. (См. раздел 5).
5.  **Остановка системы:** После вывода всей информации ядро входит в бесконечный цикл `for(;;) { __asm__ __volatile__("hlt"); }`. Инструкция `hlt` останавливает CPU до следующего прерывания. Поскольку прерывания отключены, это приводит к полной и окончательной остановке системы.

## 5. Диагностический вывод

Экран паники KyroOS спроектирован для предоставления максимального количества отладочной информации.

### 5.1. Структура экрана
Экран условно разделен на несколько областей:

- **Верхний левый угол:** Основное сообщение о причине паники.
- **Верхний правый угол:** Общая системная информация.
- **Центральная область:** Детальная информация об ошибке, включая дампы регистров и логов.
- **Нижний правый угол:** QR-код (заглушка) со ссылкой на документацию.

### 5.2. Содержимое вывода

- **System Info:**
    - `KyroOS Version`: Версия и номер сборки.
    - `CPU`: Бренд и модель процессора.
    - `RAM`: Использование оперативной памяти (used / total MB).
    - `Display`: Разрешение и глубина цвета framebuffer.
- **Last Log Messages:**
    - Отображаются последние 5 сообщений, записанных через `klog`. Это помогает восстановить последовательность событий, предшествовавших сбою.
- **Register Dump:**
    - Полный дамп 16 основных 64-битных регистров общего назначения (RAX, RBX, ..., R15).
    - `RIP`: Указатель на инструкцию, вызвавшую сбой (или следующую за ней).
    - `RSP`: Указатель на вершину стека.
    - `RBP`: Указатель на базу текущего стекового фрейма.
    - `RFL` (RFLAGS): Флаги процессора.
    - `CS`, `SS`: Селекторы сегментов кода и стека.
    - `INT`: Номер прерывания (исключения).
    - `ERR`: Код ошибки, предоставленный процессором.
- **Page Fault Details (только для #14):**
    - `Faulting Address (CR2)`: Линейный адрес, доступ к которому вызвал сбой.
    - **Декодированный код ошибки:**
        - `(P)`: Page Not Present / Protection Violation.
        - `(W/R)`: Read / Write Operation.
        - `(U/S)`: User / Supervisor Mode.
        - `(RSVD)`: Reserved Bit Set.
        - `(I/D)`: Instruction Fetch.
- **Stack Trace:**
    - Вывод цепочки вызовов путем обхода стековых фреймов, начиная с `RBP`. Отображаются адреса возврата (`RIP`) для последних 10 функций в стеке.

## 6. Поведение системы после паники

После вызова `panic()` система считается неработоспособной. **Восстановление или продолжение работы невозможно.** Единственное штатное действие после отображения экрана паники — полная перезагрузка или выключение системы пользователем. Система остается в замороженном состоянии (`hlt`) до аппаратного сброса.

## 7. Debug vs Production

В сборках для разработки (`Debug`) может быть включен флаг `epstein=1`, который предоставляет дополнительные возможности, в том числе и для отладки паники:

- **Команда `panic <reason>`:** Встроенная в shell команда позволяет вручную инициировать панику с заданным сообщением. Это используется для тестирования работы самого обработчика паники и для симуляции сбоев.

В `Production` сборках этот флаг должен быть всегда отключен, и возможность вручную вызвать панику отсутствует для обеспечения стабильности и безопасности.

## 8. Примеры и разборы

### Пример 1: Паника из-за Page Fault
- **Сценарий:** Ядро пытается выполнить запись по нулевому указателю.
- **Обнаружение:** CPU генерирует исключение Page Fault (#14), так как первая страница памяти обычно не отображена или защищена от записи.
- **Диагностика на экране паники:**
    - **Message:** `Page Fault`
    - **INT:** `0e` (14)
    - **ERR:** Код ошибки, указывающий на `Write Operation` в `Supervisor Mode` к `Page Not Present`.
    - **CR2:** `0000000000000000` (или близкое к нулю значение).
    - **RIP:** Адрес инструкции, пытавшейся выполнить запись.
    - **Stack Trace:** Поможет определить, какая функция выполнила неверную операцию.

### Пример 2: Паника по Assertion
- **Сценарий:** Функция, ожидающая на вход ненулевой указатель, получает `NULL` и проверяет это через `ASSERT(ptr != NULL)`.
- **Обнаружение:** Макрос `ASSERT` разворачивается в проверку. При ложном условии он вызывает `panic()`.
- **Диагностика на экране паники:**
    - **Message:** "Assertion failed: ptr != NULL at src/kernel/some_file.c:123" (или похожее, в зависимости от реализации `ASSERT`).
    - **Register Dump & Stack Trace:** Показывают контекст, в котором был сделан некорректный вызов, позволяя отследить источник `NULL`.
    - `INT` и `ERR` в этом случае могут не иметь значения, так как паника инициирована программно.
# 4. Ядро (Kernel)

## 4.1. Структура ядра

Ядро KyroOS имеет **монолитную** архитектуру. Это означает, что все основные компоненты — управление памятью, планировщик задач, файловая система, сетевой стек и драйверы устройств — находятся в одном адресном пространстве и выполняются на уровне привилегий Ring 0.

### Структура исходного кода

Исходный код ядра организован в следующих ключевых директориях:
- `src/kernel/`: Основная логика подсистем ядра (C-файлы).
- `src/boot/`: Низкоуровневый ассемблерный код для загрузки и переключения контекста.
- `src/include/`: Заголовочные файлы для всех подсистем, определяющие API и структуры данных.

### Основные компоненты

Ядро состоит из тесно интегрированных, но логически разделенных компонентов:
- **Менеджер физической памяти (PMM):** Отвечает за учет и распределение страниц физической памяти.
- **Менеджер виртуальной памяти (VMM):** Управляет адресными пространствами процессов, таблицами страниц и обеспечивает изоляцию памяти.
- **Планировщик (Scheduler):** Реализует многозадачность, переключая контекст между потоками.
- **Системные вызовы (Syscall):** Механизм, через который пользовательские приложения запрашивают сервисы у ядра.
- **Виртуальная файловая система (VFS):** Абстрактный слой для работы с различными файловыми системами.
- **Драйверы:** Модули, управляющие конкретными аппаратными устройствами (клавиатура, таймер, IDE, E1000).

## 4.2. Планировщик задач

Планировщик отвечает за реализацию вытесняющей многозадачности.

### Алгоритм

Используется классический алгоритм **Round-Robin** (циклический или "карусельный"). Каждому готовому к выполнению потоку выделяется определенный квант времени. Если поток не завершается и не блокируется за этот квант, он принудительно прерывается, и процессор передается следующему потоку в очереди.

### Квант времени

Системный таймер настроен на генерацию прерывания с частотой **100 Гц**. Это означает, что планировщик вызывается каждые **10 миллисекунд**, что и является квантом времени для каждого потока.

### Структура данных

Все потоки в системе организованы в виде **односвязного циклического списка** (`ready_queue`). Указатель `ready_queue` ссылается на "хвост" очереди. Соответственно, `ready_queue->next` является "головой" очереди — следующим кандидатом на выполнение.

### Логика работы (`schedule()`)

Функция `schedule()` вызывается обработчиком прерывания таймера. Ее логика следующая:
1.  Отключаются прерывания для обеспечения атомарности операции.
2.  Планировщик ищет в циклическом списке следующий поток в состоянии `THREAD_READY`.
3.  Во время поиска он выполняет "сборку мусора": если встречается поток в состоянии `THREAD_DEAD`, планировщик освобождает все выделенные ему ресурсы (стек ядра, стек пользователя, таблицы страниц) и удаляет его из списка.
4.  Если текущий выполняемый поток (`current_thread`) переходит в состояние `THREAD_READY` (его квант времени истек), он остается в списке для последующего выполнения.
5.  Найденный следующий поток для выполнения помечается как `THREAD_RUNNING`.
6.  Если был найден новый поток для выполнения, отличный от предыдущего, вызывается низкоуровневая функция `thread_switch()` для выполнения переключения контекста.

## 4.3. Процессы и потоки

В KyroOS основной единицей планирования является **поток** (`thread_t`). Понятие **процесса** является логической абстракцией и не представлено отдельной структурой. Процесс — это совокупность одного или нескольких потоков, которые выполняются в общем виртуальном адресном пространстве и разделяют общие ресурсы.

### Структура `thread_t`
Ключевые поля структуры `thread_t` (`src/include/thread.h`):
- `id`: Уникальный идентификатор потока.
- `state`: Текущее состояние (`THREAD_RUNNING`, `THREAD_READY`, `THREAD_BLOCKED`, `THREAD_DEAD`).
- `stack`: Указатель на вершину стека ядра данного потока.
- `user_stack_base`: Указатель на основание стека в пользовательском пространстве.
- `rsp`: Сохраненное значение регистра `RSP` (указателя стека ядра) в момент, когда поток был прерван.
- `pml4`: Указатель на таблицу страниц верхнего уровня (PML4), которая определяет виртуальное адресное пространство потока. Потоки одного процесса разделяют один и тот же `pml4`.
- `fd_table`: Собственная таблица файловых дескрипторов.
- `next`: Указатель на следующий поток в циклическом списке планировщика.

## 4.4. Контекстное переключение

Переключение контекста — это низкоуровневая операция сохранения состояния одного потока и восстановления состояния другого. Она реализована в ассемблерной функции `thread_switch` (`src/boot/switch.asm`).

### Процедура `thread_switch(old_thread, new_thread)`

1.  **Сохранение регистров `old_thread`:**
    *   Регистры `rbp`, `rbx`, `r12`, `r13`, `r14`, `r15` (callee-saved) сохраняются в текущем стеке ядра.
    *   Указатель инструкций (`rip`) неявно сохраняется на стеке инструкцией `call`, которая привела к вызову планировщика.
2.  **Сохранение указателя стека:** Текущее значение регистра `rsp` сохраняется в структуре старого потока: `old_thread->rsp = rsp`.
3.  **Переключение адресного пространства:**
    *   Происходит сравнение указателей `pml4` старого и нового потоков.
    *   **Если указатели отличаются**, это означает переключение между разными процессами. В таком случае физический адрес `pml4` нового потока загружается в регистр `CR3`. Это атомарно переключает все виртуальное адресное пространство.
    *   **Если указатели совпадают**, переключение `CR3` не требуется, так как потоки принадлежат одному процессу.
4.  **Восстановление контекста `new_thread`:**
    *   Значение указателя стека восстанавливается из структуры нового потока: `rsp = new_thread->rsp`.
    *   Регистры `rbp`, `rbx` и т.д. восстанавливаются со стека нового потока в обратном порядке.
5.  **Возврат из функции:** Инструкция `ret` снимает со стека сохраненный ранее `rip` нового потока и совершает переход по этому адресу. С этого момента начинает выполняться новый поток с того места, где он был прерван.# 18. Ограничения и известные проблемы

KyroOS находится на стадии активной разработки (alpha-версия) и не предназначена для использования в производственных средах. В текущей реализации присутствует ряд ограничений и не полностью реализованных функциональных возможностей.

## 18.1. Архитектурные ограничения

### Управление памятью

-   **Примитивная аллокация блоков `fs_disk`:** Дисковая файловая система `fs_disk` использует очень упрощенный механизм выделения блоков (счетчик `next_free_block`), что приводит к невозможности повторного использования освобожденных блоков и быстрой фрагментации дискового пространства.
-   **Неэффективная запись `KyroFS`:** Операции записи в in-memory файловую систему KyroFS могут быть неэффективными, особенно при увеличении размера файлов, из-за частых операций `kmalloc`/`kfree` и `memcpy` для перераспределения буферов.

### Многозадачность и синхронизация

-   **Отсутствие полноценных примитивов синхронизации:** В ядре отсутствуют мьютексы, семафоры и спинлоки. Единственный механизм синхронизации — глобальное отключение/включение прерываний, что является грубым методом и неприемлемо для длительных блокировок.
-   **Отсутствие поддержки многоядерности (SMP):** Ядро спроектировано для однопроцессорных систем. Отсутствие спинлоков и других механизмов защиты общих данных делает его непригодным для работы на многоядерных процессорах без существенных доработок.
-   **Неполный механизм блокировки потоков:** Несмотря на наличие состояния `THREAD_BLOCKED`, полноценный механизм перевода потоков в ожидание и их пробуждения (например, по событию или освобождению ресурса) реализован лишь частично и требует доработки.

### Файловая система

-   **Низкая масштабируемость `fs_disk`:** `fs_disk` является плоской файловой системой (нет поддержки иерархических директорий) с жестким ограничением на количество файлов (32). Она не интегрирована в VFS.
-   **Отсутствие модели прав доступа:** Ни VFS, ни конкретные реализации ФС (`KyroFS`, `fs_disk`) не поддерживают полноценную модель прав доступа (пользователь, группа, другие; чтение, запись, выполнение).
-   **Отсутствие кэширования данных в `fs_disk`:** Дисковая ФС не кэширует блоки данных, что приводит к прямому обращению к диску при каждом чтении/записи и снижает производительность.

### Сеть

-   **Тесная связь ядра сети с драйвером:** Основные функции сетевого ядра (`net_init`, `net_register_device`) реализованы внутри драйвера E1000, что делает подсистему менее модульной и затрудняет добавление других сетевых драйверов.
-   **Частичная реализация TCP:** Протокол TCP реализован не полностью, хотя и содержит конечный автомат состояний. Возможны проблемы с надежностью, производительностью и соответствием спецификациям.

### Графическая подсистема

-   **Отсутствие ускорения GPU:** Все графические операции выполняются программно центральным процессором, что ограничивает производительность.
-   **Прямой доступ к Framebuffer для Userspace:** Пользовательские приложения получают прямой, неограниченный доступ к памяти framebuffer, что упрощает разработку, но не предоставляет защиты и требует, чтобы вся логика оконной системы (композиция, управление окнами) реализовывалась в пользовательском пространстве.
-   **Внутренний GUI:** Существующий GUI-тулкит ядра (`gui.c`) предназначен исключительно для внутреннего использования и не предоставляет API для приложений пользовательского пространства.

### Межпроцессное взаимодействие (IPC)

-   **Отсутствие каналов (Pipes):** Классический механизм IPC "каналы" не реализован.
-   **Отсутствие явного API разделяемой памяти:** Хотя потоки одного процесса разделяют память, явного API для создания и управления сегментами разделяемой памяти для разных процессов не предусмотрено.

## 18.2. Нереализованные подсистемы

-   **USB-стек:** Поддержка устройств USB отсутствует.
-   **AHCI-драйвер:** Поддержка современных SATA-контроллеров отсутствует, используется только устаревший IDE-драйвер.
-   **Полноценная `libc`:** Отсутствует полноценная стандартная библиотека C для пользовательского пространства, что вынуждает приложения либо использовать минимальные обертки syscall, либо включать свою реализацию.
-   **Виртуализация:** На данный момент никаких механизмов аппаратной или программной виртуализации не предусмотрено.

## 18.3. Компромиссы проектирования

-   **Простота и читаемость:** Многие решения в KyroOS приняты в угоду простоте реализации и легкости понимания кода, что иногда идет в ущерб производительности, безопасности или функциональности.
-   **Минимализм:** Целью было создание работающей системы с нуля, а не полноценной коммерческой ОС. Это привело к сознательному отказу от многих сложных функций на начальных этапах.
-   **Образовательная направленность:** Система служит учебным проектом, что объясняет некоторые упрощения и "TODO" в коде.

## 18.4. Известные проблемы

-   **Альфа-качество:** Система находится в альфа-стадии разработки, что означает высокую вероятность наличия багов, нестабильность и возможные непредвиденные сбои.
-   **Несоответствие POSIX:** API KyroOS не полностью соответствует стандарту POSIX, что затрудняет портирование существующего программного обеспечения.
-   **Низкая производительность:** Из-за отсутствия оптимизаций, развитых алгоритмов и кэширования в некоторых подсистемах производительность может быть низкой.
# 5. Управление памятью

Управление памятью в KyroOS построено на двухуровневой модели, стандартной для современных операционных систем: менеджер физической памяти (PMM) управляет реальными ресурсами ОЗУ, а менеджер виртуальной памяти (VMM) предоставляет изолированные адресные пространства для каждого процесса.

## 5.1. Физическая память (PMM)

Менеджер физической памяти (`Physical Memory Manager`) отвечает за учет, выделение и освобождение страниц физической оперативной памяти.

### Стратегия

PMM использует **битмап (bitmap)** для отслеживания состояния каждой физической страницы в системе. Каждой странице размером 4 КБ соответствует один бит в битмапе: 1 означает, что страница занята, 0 — свободна.

### Инициализация (`pmm_init`)

1.  При загрузке ядро получает от загрузчика Limine карту памяти (`memory map`), в которой перечислены все доступные диапазоны ОЗУ и их типы (usable, reserved, ACPI, etc.).
2.  PMM находит самый большой диапазон в памяти и вычисляет общий объем ОЗУ, а также размер, необходимый для хранения самого битмапа.
3.  Затем он находит в карте памяти первый достаточно большой *свободный* участок и размещает в нем битмап.
4.  Изначально весь битмап заполняется единицами (вся память считается занятой).
5.  Далее PMM проходит по карте памяти еще раз и обнуляет биты для тех страниц, которые Limine пометил как `USABLE` (доступные для использования).
6.  Наконец, биты, соответствующие страницам, на которых расположен сам битмап, снова выставляются в 1, чтобы защитить его от перезаписи.

### Аллокация и освобождение

-   **`pmm_alloc_page()`:** Выполняет линейный поиск в битмапе, начиная с места последней успешной аллокации. Найдя первый свободный бит (0), он выставляет его в 1 и возвращает соответствующий физический адрес страницы. Это простая реализация алгоритма "next-fit".
-   **`pmm_free_page(address)`:** Вычисляет индекс страницы по ее физическому адресу и обнуляет соответствующий бит в битмапе.

## 5.2. Виртуальная память (VMM)

Менеджер виртуальной памяти (`Virtual Memory Manager`) отвечает за создание и управление виртуальными адресными пространствами. Это ключевой механизм, обеспечивающий изоляцию процессов и защиту памяти.

### Архитектура

KyroOS использует **4-уровневую модель страничной адресации (Paging)**, стандартную для архитектуры x86-64. Каждое виртуальное адресное пространство описывается иерархией из четырех таблиц:
1.  Page Map Level 4 (PML4) - Таблица 4-го уровня (корневая)
2.  Page Directory Pointer Table (PDPT) - Таблица указателей каталогов страниц
3.  Page Directory (PD) - Каталог страниц
4.  Page Table (PT) - Таблица страниц

Каждая таблица содержит 512 64-битных записей. Каждая запись в PT указывает на физическую страницу размером 4 КБ.

### Адресное пространство

64-битное виртуальное адресное пространство разделено на две половины:
- **Нижняя половина (User Space):** Адреса от `0x0000000000000000` до `0x00007FFFFFFFFFFF`. Эта часть уникальна для каждого процесса и содержит его код, данные, кучу и стек.
- **Верхняя половина (Kernel Space):** Адреса от `0xFFFF800000000000` и выше. Эта часть одинакова для всех процессов и содержит код и данные ядра, а также прямое отображение всей физической памяти (Higher-Half Direct Map, HHDM).

### Higher-Half Direct Map (HHDM)

Вся физическая память отображается в верхней половине виртуального адресного пространства с постоянным смещением (`hhdm_offset`). Это позволяет ядру иметь прямой доступ к любой физической странице, просто прибавив к ее адресу это смещение. Функции `p_to_v()` (physical-to-virtual) и `v_to_p()` (virtual-to-physical) используются для такого преобразования.

### Создание адресного пространства (`vmm_create_address_space`)

При создании нового процесса:
1.  PMM выделяет одну страницу для новой PML4-таблицы.
2.  Нижняя половина этой таблицы (первые 256 записей), отвечающая за User Space, обнуляется.
3.  **Верхняя половина** (последние 256 записей), отвечающая за Kernel Space, **копируется** из PML4-таблицы ядра.
Таким образом, ядро всегда отображено в каждом процессе, что делает обработку системных вызовов и прерываний очень эффективной, так как не требует смены адресного пространства.

## 5.3. Аллокаторы

### Kernel Heap (`kmalloc`/`kfree`)

Для динамического выделения памяти внутри ядра (например, для создания структур данных) используется аллокатор кучи.

- **Стратегия:** Реализация основана на классическом аллокаторе из книги K&R. Он использует **связный список свободных блоков памяти**.
- **`kmalloc()`:** При запросе на выделение памяти, аллокатор ищет в списке свободных блоков первый подходящий по размеру (first-fit/next-fit). Если блок больше запрошенного, он разбивается на две части.
- **`kfree()`:** Освобождаемый блок добавляется в список свободных. Аллокатор также выполняет **слияние (coalescing)**: если освобождаемый блок граничит с другим свободным блоком, они объединяются в один большой блок для борьбы с фрагментацией.
- **`morecore()`:** Если `kmalloc` не может найти подходящий блок, он вызывает внутреннюю функцию `morecore`, которая запрашивает у PMM одну или несколько новых физических страниц, отображает их в виртуальном пространстве ядра и добавляет этот новый большой кусок памяти в список свободных блоков.

## 5.4. Защита памяти

Защита памяти обеспечивается на аппаратном уровне процессором, а настраивается через VMM.

- **Изоляция процессов:** Каждый процесс имеет собственную PML4-таблицу, поэтому он не может получить доступ к данным других процессов. Все его виртуальные адреса в конечном итоге ссылаются на физические страницы, выделенные ему PMM'ом.
- **Защита ядра от пользовательского пространства:** В записях таблиц страниц, описывающих память ядра, установлен флаг `Supervisor`. Попытка доступа к этим страницам из пользовательского пространства (Ring 3) вызовет исключение General Protection Fault.
- **Защита от записи и выполнения:** Для каждой страницы можно установить флаги:
    - **`PAGE_WRITE`:** Определяет, разрешена ли запись в страницу. Код программы обычно находится на страницах "только для чтения".
    - **`PAGE_NO_EXEC` (NX Bit):** Запрещает выполнение кода со страниц, помеченных этим флагом (например, со стека или кучи), что является важной мерой безопасности против атак типа "buffer overflow".# 13. Сеть

Сетевая подсистема KyroOS реализована в виде многоуровневого стека протоколов, который обеспечивает взаимодействие с сетью, включая низкоуровневые операции с сетевым оборудованием и высокоуровневый API сокетов для пользовательских приложений.

## 13.1. Архитектура сетевого стека

Сетевой стек KyroOS имеет традиционную многоуровневую архитектуру:

1.  **Канальный уровень (Data Link Layer):** Представлен сетевыми драйверами (например, E1000). Отвечает за передачу данных в пределах одного сегмента сети (LAN), используя MAC-адреса. Включает протокол ARP.
2.  **Сетевой уровень (Network Layer):** Представлен протоколом IP (IPv4). Отвечает за маршрутизацию пакетов между различными сетями, используя IP-адреса.
3.  **Транспортный уровень (Transport Layer):** Представлен протоколами UDP и TCP. Отвечает за надежную или ненадежную доставку данных между приложениями на разных хостах.
4.  **Уровень сокетов (Sockets Layer):** Предоставляет стандартизированный программный интерфейс (API) для приложений пользовательского пространства для взаимодействия с сетевым стеком.

На текущем этапе **реализация сетевого ядра (`net_init`, `net_register_device`) находится непосредственно в исходном коде драйвера E1000 (`src/kernel/e1000.c`)**. Это указывает на тесную связь и ранний этап абстракции, где общие функции управления сетевыми устройствами пока не выделены в отдельный модуль.

### Путь пакета

#### Входящий пакет:

1.  **Драйвер сетевой карты (E1000):** При получении фрейма E1000 прерывает CPU. Обработчик прерывания (`e1000_interrupt_handler`) считывает фрейм из буферов DMA.
2.  **Демультиплексирование Ethernet:** Драйвер анализирует поле `EtherType` заголовка Ethernet:
    *   Если `ARP_ETHER_TYPE`, фрейм передается в `arp_handle_packet()`.
    *   Если `ETHERTYPE_IPV4`, фрейм передается в `ip_handle_packet()`.
3.  **IP-уровень:** `ip_handle_packet()` обрабатывает IP-заголовок (проверяет контрольную сумму, TTL) и демультиплексирует пакет на основе поля `Protocol`:
    *   Если `IP_PROTOCOL_UDP`, пакет передается в `udp_handle_packet()`.
    *   Если `IP_PROTOCOL_TCP`, пакет передается в `tcp_handle_packet()`.
    *   Если `IP_PROTOCOL_ICMP`, пакет передается в `icmp_handle_packet()`.
4.  **Транспортный уровень (UDP/TCP/ICMP):** Соответствующий обработчик анализирует заголовок своего протокола.
    *   Для UDP/TCP пакеты, предназначенные для открытых сокетов, передаются в `sock_handle_incoming_packet()`.
5.  **Уровень сокетов:** `sock_handle_incoming_packet()` находит соответствующий сокет (`socket_t`) на основе IP-адреса, порта и протокола, и помещает данные во внутренний буфер сокета. Если есть ждущий поток, он может быть разблокирован.

#### Исходящий пакет:

1.  **Пользовательское приложение:** Вызывает системный вызов (например, `SYS_SEND`), который через обертку `sock_send()` передает данные на уровень сокетов.
2.  **Уровень сокетов:** Функция `sock_send()` (или `sock_connect`) определяет, какой транспортный протокол (UDP/TCP) должен использоваться, и вызывает соответствующую протокол-специфичную функцию (например, `udp_send_packet` или `tcp_send_tcb`).
3.  **Транспортный уровень (UDP/TCP):** Формируется заголовок UDP/TCP. Затем вызывается `ip_send_packet()`.
4.  **IP-уровень:** `ip_send_packet()` формирует IP-заголовок, определяет MAC-адрес получателя через ARP-запросы (при необходимости) и вызывает функцию `send_packet` зарегистрированного сетевого устройства (например, `e1000_send_packet`).
5.  **Драйвер сетевой карты (E1000):** `e1000_send_packet()` формирует Ethernet-фрейм, помещает его в буфер DMA и инициирует передачу по сети.

## 13.2. Поддерживаемые протоколы

KyroOS поддерживает следующие сетевые протоколы:

-   **ARP (Address Resolution Protocol):** Для сопоставления IP-адресов с MAC-адресами.
-   **IP (Internet Protocol, IPv4):** Базовый протокол сетевого уровня.
-   **ICMP (Internet Control Message Protocol):** Протокол для обмена сообщениями об ошибках и других операционных сообщениях в сети (например, ping).
-   **UDP (User Datagram Protocol):** Простой, без установления соединения, ненадежный протокол транспортного уровня.
-   **TCP (Transmission Control Protocol):** Протокол транспортного уровня с установлением соединения, надежной доставкой и управлением потоком. Реализация является частичной, но функциональной, с поддержкой конечного автомата состояний TCP.
-   **DHCP (Dynamic Host Configuration Protocol):** Для автоматического получения IP-адреса и других сетевых настроек от DHCP-сервера.

## 13.3. Сетевые драйверы

На данный момент KyroOS поддерживает драйвер для **Intel E1000 Ethernet (Gigabit Ethernet Controller)**, который широко используется в виртуальных машинах (QEMU, VMware) и некоторых реальных системах.

-   **Регистрация:** Драйвер E1000 регистрирует себя в Device Manager и, после обнаружения и инициализации оборудования, регистрирует свою `net_dev_t` структуру в сетевой подсистеме (`net_register_device()`).
-   **Функциональность:** Предоставляет функции `send_packet` для отправки Ethernet-фреймов и обрабатывает входящие фреймы через свой обработчик прерываний.
# KyroOS: Техническая спецификация

## 1. Введение

### 1.1. Назначение ОС

KyroOS — это экспериментальная, самописная операционная система общего назначения для 64-битной архитектуры x86-64. Она не основана на существующих ядрах, таких как Linux или BSD. Система спроектирована с нуля в образовательных целях для исследования и практической реализации ключевых концепций современных операционных систем.

### 1.2. Область применения

Основная область применения KyroOS — образовательная и исследовательская. Система служит платформой для изучения низкоуровневого программирования, архитектуры ядра, разработки драйверов и системных утилит.

KyroOS не предназначена для производственного (production) использования. Статус проекта — **alpha**, что подразумевает наличие известных и неизвестных ошибок, неполную реализацию функционала и возможную нестабильность.

### 1.3. Цели проектирования

При разработке KyroOS были поставлены следующие инженерные цели:

*   **Простота и читаемость кода:** Архитектура и код должны быть достаточно просты для изучения и понимания ключевых механизмов. Предпочтение отдается ясным и прямолинейным реализациям перед чрезмерно сложными оптимизациями.
*   **Расширяемость:** Архитектура должна позволять относительно простое добавление новых модулей, драйверов и системных вызовов.
*   **Соответствие современным концепциям:** Реализация должна отражать стандартные подходы, используемые в современных 64-битных ОС (виртуальная память, вытесняющая многозадачность, разделение на пространство ядра и пользователя).
*   **Самодостаточность:** Система должна быть минимально зависимой от внешних библиотек и сред выполнения на уровне ядра.

### 1.4. Архитектурные принципы

*   **Монолитное ядро:** Все основные сервисы ОС (управление процессами, памятью, файловой системой, драйверы) работают в едином адресном пространстве ядра для повышения производительности.
*   **Привилегированное ядро и непривилегированное пользовательское пространство:** Четкое разделение между режимом ядра (Ring 0) и режимом пользователя (Ring 3) для обеспечения защиты и стабильности системы.
*   **Вытесняющая многозадачность:** Планировщик по таймеру прерывает выполнение задач, обеспечивая псевдопараллельное выполнение нескольких процессов.
*   **Аппаратная абстракция:** Взаимодействие с оборудованием осуществляется через стандартизированные драйверные интерфейсы.

## 2. Общая архитектура

### 2.1. Тип ядра

Ядро KyroOS является **монолитным** с поддержкой загружаемых модулей (Loadable Kernel Modules, LKM).

Ключевые подсистемы, включая планировщик, VFS, сетевой стек и драйверы устройств, скомпилированы как единый бинарный файл и работают в одном адресном пространстве (Ring 0). Это обеспечивает высокую производительность за счет прямого вызова функций вместо медленных IPC-механизмов, характерных для микроядер. Поддержка LKM позволяет динамически (во время работы системы) загружать и выгружать код в ядро, например, для добавления поддержки нового оборудования.

### 2.2. Поддерживаемые архитектуры CPU

На данный момент KyroOS поддерживает только архитектуру **x86-64**.

Система использует 64-битный "длинный" режим (long mode), 4-уровневую структуру таблиц страниц (PML4) и регистры, специфичные для x86-64. Сборка кода ядра производится с флагами `-m64` и `-march=x86-64`. Ядро не использует расширения MMX и SSE для обеспечения простоты, но они могут использоваться в пользовательском пространстве.

### 2.3. Режимы работы процессора

KyroOS использует два уровня привилегий архитектуры x86-64:

*   **Режим ядра (Supervisor Mode, Ring 0):** В этом режиме выполняется все ядро, включая обработчики прерываний и системных вызовов, а также драйверы. Код в Ring 0 имеет полный доступ ко всему адресному пространству и всем инструкциям процессора.
*   **Режим пользователя (User Mode, Ring 3):** В этом режиме выполняются все пользовательские приложения (например, shell, утилиты). Код в Ring 3 изолирован: он имеет доступ только к своему собственному виртуальному адресному пространству и не может выполнять привилегированные инструкции. Взаимодействие с ядром происходит исключительно через механизм системных вызовов.

### 2.4. Модель многозадачности

KyroOS реализует **вытесняющую многозадачность** (Preemptive Multitasking) на основе временных интервалов (time-slicing).

*   **Сущности:** Система оперирует понятиями **процессов** и **потоков** (хотя текущая реализация может быть ближе к модели "один процесс — один поток").
*   **Планировщик:** Используется планировщик типа "Round-Robin". Каждому активному потоку выделяется квант времени. По истечении кванта системный таймер генерирует прерывание (IRQ), обработчик которого вызывает планировщик.
*   **Переключение контекста:** Планировщик выбирает следующий поток для выполнения и выполняет переключение контекста. Этот процесс включает сохранение состояния регистров текущего потока и загрузку состояния следующего потока.
*   **Состояния:** Потоки могут находиться в различных состояниях (например, `RUNNING`, `READY`, `BLOCKED`). Блокировка происходит при ожидании событий, таких как завершение операции ввода-вывода или освобождение ресурса синхронизации.
# 14. Безопасность

Модель безопасности KyroOS, будучи экспериментальной операционной системой, сосредоточена на фундаментальных механизмах защиты, предоставляемых аппаратным обеспечением, для обеспечения изоляции процессов и защиты ядра от несанкционированного доступа.

## 14.1. Модель безопасности

Базовая модель безопасности KyroOS строится на концепции **изоляции ресурсов** и **привилегий**. Основные принципы:

-   **Разделение привилегий:** Строгое разделение между привилегированным режимом ядра (Ring 0) и непривилегированным режимом пользователя (Ring 3).
-   **Изоляция памяти:** Каждый процесс выполняется в собственном виртуальном адресном пространстве, предотвращая прямой доступ к памяти других процессов или ядра.
-   **Контролируемый доступ к ресурсам:** Все операции с системными ресурсами (файлы, устройства, сеть) доступны только через строго определенный API системных вызовов, которые валидируются ядром.

Отсутствие полноценной системы управления пользователями, групп, а также детальных прав доступа к файлам (chmod, chown) на данном этапе является значительным ограничением.

## 14.2. Изоляция процессов

Изоляция процессов является краеугольным камнем стабильности и безопасности многозадачной операционной системы. KyroOS реализует ее преимущественно через механизмы виртуальной памяти.

-   **Виртуальные адресные пространства:** Каждый процесс имеет собственное 4-уровневое виртуальное адресное пространство, описываемое уникальной таблицей PML4 (Page Map Level 4). Это означает, что виртуальный адрес `0x100000` в одном процессе может указывать на совершенно другой физический участок памяти, чем тот же адрес в другом процессе.
-   **Отсутствие прямого доступа:** Пользовательский процесс (работающий в Ring 3) не может получить прямой доступ к памяти других процессов или к памяти ядра. Любая такая попытка генерирует исключение (например, Page Fault или General Protection Fault), которое перехватывается ядром.
-   **Флаги защиты страниц:** Менеджер виртуальной памяти (VMM) устанавливает соответствующие флаги защиты в записях таблиц страниц:
    -   `PAGE_USER`: Разрешает доступ из пользовательского режима. Если этот флаг не установлен, доступ возможен только из режима ядра.
    -   `PAGE_WRITE`: Разрешает запись. Страницы с кодом программы обычно помечены как "только для чтения".
    -   `PAGE_NO_EXEC` (NX Bit): Запрещает выполнение кода со страниц, помеченных этим флагом (например, со стека или кучи), предотвращая некоторые виды атак, связанные с инъекцией кода.

## 14.3. Защита ядра

Защита ядра от вредоносных или ошибочных действий пользовательских приложений (и, в меньшей степени, от ошибок в самом ядре) является приоритетом.

-   **Пространство ядра:** Код и данные ядра всегда находятся в верхней половине виртуального адресного пространства, изолированно от пользовательской памяти.
-   **Привилегии Ring 0:** Код ядра выполняется на максимальном уровне привилегий (Ring 0), имея полный доступ ко всем системным ресурсам и инструкциям процессора. Пользовательские процессы (Ring 3) не могут выполнять привилегированные инструкции.
-   **Защита памяти ядра:** Страницы, содержащие код и данные ядра, отображаются с флагом `PAGE_SUPERVISOR` (что эквивалентно отсутствию `PAGE_USER` флага), что делает их недоступными из пользовательского режима.
-   **Контролируемый переход:** Единственный санкционированный путь перехода из пользовательского режима в режим ядра — это механизм **системных вызовов** (`int 0x80`). Все параметры, передаваемые пользовательским приложением в системный вызов, должны быть тщательно проверены ядром на валидность и безопасность, прежде чем будут использованы.
-   **Обработка критических ошибок:** Любое необработанное исключение (например, Page Fault или General Protection Fault) в режиме ядра немедленно приводит к **Kernel Panic**. Это предотвращает потенциальное повреждение данных или дальнейшую нестабильность системы, сигнализируя о фатальной ошибке.
-   **Отсутствие LKM для пользовательских приложений:** Несмотря на поддержку Loadable Kernel Modules, механизм загрузки модулей контролируется только ядром и не предоставляется пользовательским приложениям, что предотвращает инъекцию несанкционированного кода в ядро.
# 7. Системные вызовы

Системные вызовы (syscalls) — это основной интерфейс, через который приложения пользовательского пространства (Ring 3) запрашивают у ядра выполнение привилегированных операций, таких как работа с файлами, управление памятью или взаимодействие с устройствами.

## 7.1. Механизм системных вызовов

Механизм системных вызовов в KyroOS использует программное прерывание.

1.  **Инициация:** Пользовательское приложение загружает номер системного вызова и его аргументы в регистры согласно ABI, после чего выполняет инструкцию `int 0x80`.
2.  **Переход в ядро:** Процессор генерирует прерывание с вектором 128 (0x80). Это вызывает переключение с Ring 3 на Ring 0 и передачу управления обработчику прерываний ядра.
3.  **Низкоуровневый обработчик (`isr128`):** Ассемблерная заглушка, ассоциированная с вектором 128, выполняет следующие действия:
    *   Сохраняет полный контекст регистров пользовательского потока на его стеке ядра.
    *   Вызывает высокоуровневый C-диспетчер `syscall_handler()`, передавая ему указатель на сохраненные регистры.
4.  **Диспетчер (`syscall_handler`):**
    *   Извлекает номер системного вызова из сохраненного регистра `rax`.
    *   Использует этот номер как индекс в глобальной таблице `syscall_table` для поиска адреса функции, реализующей данный syscall.
    *   Если обработчик найден, он вызывается. Ему также передается указатель на `struct registers`.
5.  **Выполнение:** Конкретный обработчик (например, `sys_write`) извлекает свои аргументы из сохраненных регистров (`rdi`, `rsi` и т.д.), выполняет необходимую работу и записывает результат (возвращаемое значение) обратно в поле `rax` в структуре `registers` на стеке.
6.  **Возврат в пользовательское пространство:** После завершения работы C-обработчиков управление возвращается в `isr128`. Он восстанавливает все регистры из `struct registers` и выполняет инструкцию `iretq`. Эта инструкция атомарно возвращает управление в пользовательское приложение, восстанавливая его регистры (включая `rax` с результатом) и переключая процессор обратно в Ring 3.

## 7.2. ABI (Application Binary Interface)

Соглашение о вызовах (Calling Convention) для системных вызовов в KyroOS основано на стандарте System V AMD64 ABI.

| Регистр | Назначение                    |
| :------ | :---------------------------- |
| `rax`   | Номер системного вызова (вход), Возвращаемое значение (выход) |
| `rdi`   | 1-й аргумент                  |
| `rsi`   | 2-й аргумент                  |
| `rdx`   | 3-й аргумент                  |
| `r10`   | 4-й аргумент                  |
| `r8`    | 5-й аргумент                  |
| `r9`    | 6-й аргумент                  |

Отрицательное значение в `rax` после вызова обычно сигнализирует об ошибке.

## 7.3. Таблица системных вызовов

В ядре (`src/kernel/syscall.c`) определена статическая таблица `syscall_table` — массив из 256 указателей на функции.

```c
static void (*syscall_table[256])(struct registers *regs);
```

Функция `syscall_init()` заполняет эту таблицу, сопоставляя номера вызовов (макросы `SYS_*` из `src/include/syscall.h`) с их C-реализациями. Если приложение запрашивает несуществующий syscall, диспетчер не находит обработчика в таблице и просто возвращает управление, не производя никаких действий.

### Основные системные вызовы:

| Номер | Имя                  | Описание                                           |
| :---- | :------------------- | :------------------------------------------------- |
| 0     | `SYS_EXIT`           | Завершить текущий поток.                           |
| 1     | `SYS_WRITE`          | Записать данные в файл или стандартный вывод.      |
| 2     | `SYS_OPEN`           | Открыть или создать файл.                          |
| 3     | `SYS_CLOSE`          | Закрыть файловый дескриптор.                       |
| 4     | `SYS_READ`           | Прочитать данные из файла.                         |
| 5     | `SYS_STAT`           | Получить информацию о файле.                       |
| 6     | `SYS_MKDIR`          | Создать директорию.                                |
| 10    | `SYS_SOCKET`         | Создать конечную точку для коммуникации (сокет).   |
| 17    | `SYS_GET_TICKS`      | Получить количество тиков системного таймера.      |
| 24    | `SYS_EXEC`           | Загрузить и выполнить программу (упрощенная версия).|
| 25    | `SYS_GFX_GET_FB_INFO`| Получить информацию о framebuffer.                 |
| 26    | `SYS_INPUT_POLL_EVENT`| Опросить очередь событий ввода.                  |

*(Полный список см. в `src/include/syscall.h`)*

## 7.4. Примеры использования (C-like)

Так как системные вызовы выполняются через ассемблерные инструкции, в стандартной библиотеке пользовательского пространства (`libc`) создаются функции-обертки.

**Пример 1: Вывод строки "Hello, World!" на стандартный вывод (stdout = 1).**

```c
// Код в userspace/lib/libc/stdio.c (пример)
#include <unistd.h>
#include <string.h>

void puts(const char* str) {
    // SYS_WRITE = 1
    // 1-й аргумент (fd) = 1 (stdout)
    // 2-й аргумент (buf) = str
    // 3-й аргумент (size) = strlen(str)
    syscall(SYS_WRITE, 1, str, strlen(str));
    syscall(SYS_WRITE, 1, "\n", 1); // Добавить перевод строки
}

// Код в приложении
int main() {
    puts("Hello, World!");
    return 0;
}
```
Здесь `syscall()` — это ассемблерная функция-обертка, которая загружает аргументы в регистры и выполняет `int 0x80`.

**Пример 2: Получение текущего времени в тиках.**
```c
// Код в userspace/lib/libc/time.c (пример)
uint64_t get_ticks() {
    // SYS_GET_TICKS = 17. Аргументов нет.
    return syscall(SYS_GET_TICKS);
}
```
Здесь `syscall(SYS_GET_TICKS)` загрузит `17` в `rax`, выполнит `int 0x80`, и после возвращения из ядра вернет значение, которое ядро положило в `rax`.

# 12. Пользовательское пространство (Userspace)

Пользовательское пространство в KyroOS — это среда с низким уровнем привилегий (Ring 3), в которой выполняются все прикладные программы. Оно полностью изолировано от ядра и от других процессов. Взаимодействие с ядром и системными ресурсами осуществляется исключительно через API системных вызовов.

## 12.1. Формат исполняемых файлов

KyroOS использует стандартный, широко распространенный формат исполняемых файлов **ELF64 (Executable and Linkable Format, 64-bit)**.

-   **Спецификация:** Ядро содержит загрузчик, способный парсить заголовки ELF64 (`Elf64_Ehdr`) и заголовки программ (`Elf64_Phdr`).
-   **Тип:** Загрузчик поддерживает только исполняемые файлы (`ET_EXEC`). Релоцируемые (`ET_REL`) и разделяемые (`ET_DYN`) объектные файлы не поддерживаются.
-   **Сборка:** Пользовательские приложения должны быть статически скомпонованы и слинкованы для выполнения по фиксированным виртуальным адресам в нижней половине адресного пространства.

## 12.2. Загрузка программ

Процесс загрузки и запуска программы инициируется системным вызовом `exec` (или аналогичным) и состоит из следующих шагов:

1.  **Создание адресного пространства:** Ядро создает новое, пустое 4-уровневое страничное отображение (PML4) для нового процесса. Верхняя половина этого пространства (адреса ядра) копируется из шаблона ядра, а нижняя (пользовательская) остается пустой.
2.  **Чтение файла:** Ядро считывает ELF-файл целиком в буфер в своей памяти.
3.  **Анализ ELF:** Загрузчик `elf_load` проверяет корректность ELF-заголовка (магическое число, класс, тип).
4.  **Загрузка сегментов:** Загрузчик проходит по всем заголовкам программ (`Program Headers`).
    -   Для каждого сегмента типа `PT_LOAD` (загружаемый сегмент):
    -   Ядро выделяет необходимое количество физических страниц памяти.
    -   Эти страницы отображаются в виртуальное адресное пространство нового процесса по адресу (`p_vaddr`), указанному в заголовке сегмента.
    -   Устанавливаются флаги защиты страниц (`Read`, `Write`, `Execute`) в соответствии с флагами сегмента. Пользовательский доступ (`PAGE_USER`) всегда разрешен.
    -   Данные сегмента копируются из буфера в новые страницы. Если размер в памяти (`p_memsz`) больше размера в файле (`p_filesz`), остаток (секция `.bss`) заполняется нулями.
5.  **Создание потока:** После успешной загрузки всех сегментов ядро создает новый поток в состоянии `READY` (`thread_create_userspace`). В качестве точки входа для этого потока устанавливается адрес (`e_entry`), указанный в заголовке ELF, а в качестве адресного пространства — новое, только что созданное.
6.  **Запуск:** При следующем вызове планировщика новый поток будет выбран для выполнения и начнет свою работу в пользовательском режиме (Ring 3) с точки входа программы.

## 12.3. API для приложений

Основным и единственным API для взаимодействия приложений с ядром является **интерфейс системных вызовов**. Детали механизма, ABI и полный список вызовов описаны в разделе **[7. Системные вызовы](./syscalls.md)**.

## 12.4. Стандартные библиотеки

Полноценная стандартная библиотека C (`libc`) в KyroOS отсутствует. Вместо этого предоставляется набор небольших специализированных библиотек и самодостаточных оберток для системных вызовов.

### Обертка `syscall()`

Так как центральной `libc` нет, каждое приложение или библиотека, которым необходимо совершать системные вызовы, использует собственную локальную реализацию функции `syscall()`. Это небольшая функция, написанная на встроенном ассемблере (GCC inline assembly), которая выполняет следующие действия:
1.  Помещает номер системного вызова в регистр `rax`.
2.  Помещает аргументы в регистры `rdi`, `rsi`, `rdx` и т.д.
3.  Выполняет инструкцию `int 0x80`.
4.  Возвращает значение из регистра `rax` после завершения вызова.

### `libkyroos_gfx`

Простая графическая библиотека, предоставляющая базовые функции для рисования.
-   **Инициализация:** При инициализации (`gfx_init()`) библиотека вызывает `SYS_GFX_GET_FB_INFO`, чтобы получить от ядра прямой доступ к видеопамяти.
-   **Функционал:** Предоставляет функции `gfx_draw_pixel`, `gfx_draw_rect`, которые напрямую записывают данные в память framebuffer. Также включает обертку для `SYS_INPUT_POLL_EVENT` для получения событий ввода.

### `libtui`

Библиотека для создания текстовых пользовательских интерфейсов (Text User Interface). Является надстройкой более высокого уровня над `libkyroos_gfx`.
-   **Функционал:** Использует полученный от ядра framebuffer для отрисовки текста с помощью встроенного в библиотеку растрового шрифта (`tui_draw_text`), а также для рисования простых графических примитивов вроде прямоугольников (`tui_draw_box`).
-   **Применение:** Используется для создания псевдо-графических оконных интерфейсов без полноценной графической подсистемы.
