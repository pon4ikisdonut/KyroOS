# Kernel Panic

## 1. Definition

**Kernel Panic** is a critical error handling mechanism in the KyroOS kernel. This state arises when an unrecoverable error is detected that jeopardizes the integrity of the system and its data. When the kernel enters a panic state, it immediately halts the normal execution of all processes, saves the maximum possible amount of diagnostic information for subsequent analysis, and stops the system to prevent further damage.

The primary goal of this mechanism is not recovery, but a safe halt that provides comprehensive information for debugging.

## 2. Classification of Causes

The causes leading to a Kernel Panic fall into two main categories:

### 2.1. CPU Exceptions
The most common cause. The KyroOS kernel intercepts and handles exceptions generated by the CPU. If an exception occurs in kernel mode (Ring 0) and cannot be safely handled, a panic is initiated.

- **Page Fault (PF, #14):** An attempt to access an invalid, non-existent, or protected memory page within the kernel context.
- **General Protection Fault (GPF, #13):** A general protection violation. Examples: writing to a read-only code segment, executing privileged instructions from user mode (although this would only cause a panic if there's an error in the kernel), invalid segment selectors.
- **Double Fault (#8) / Triple Fault:** Occur when the CPU attempts to handle an exception, and in the process of handling that exception, another exception occurs that the CPU cannot handle. A Triple Fault is architecturally fatal and leads to a system reset, but a Double Fault is intercepted by the kernel and triggers a panic.
- **Invalid Opcode (UD, #6):** An attempt to execute an invalid or privileged instruction.
- **Division by Zero (DE, #0):** Integer division by zero.

### 2.2. Software Assertions
The kernel contains internal integrity checks (assertions) to verify invariants and critical conditions during execution. If a check fails, it indicates a logical error in the kernel code.

- **Kernel Assertions:** `ASSERT(condition)` macros that trigger a panic if `condition` is false. For example, checking the validity of a pointer before using it.
- **Driver Errors:** Critical errors in device drivers (e.g., hardware failure that cannot be handled).
- **Kernel Data Structure Corruption:** Detection of corruption in key structures, such as process tables, memory allocators, or system lists.
- **Initialization Errors:** Inability to initialize a critical system component during boot.

## 3. Detection Mechanism

The detection of critical errors is implemented at two levels:

1.  **Hardware Level:** Interrupt Descriptor Table (IDT) configuration. For each CPU exception considered critical for the kernel, the corresponding gate in the IDT is set to call a general exception handler. This handler saves the processor state and invokes the panic procedure.
2.  **Software Level:** Explicit calls to the `panic()` function from within kernel code. This function is called in places where the software logic detects a fatal state, for example, during a failed `ASSERT` check or when a critical resource cannot be allocated.

## 4. Handling Procedure

Upon detection of a critical error, the following sequence of actions is initiated, implemented in the `panic_screen_show()` function (`src/kernel/panic_screen.c`):

1.  **Disable Interrupts:** The `cli` instruction is executed to prevent any further interrupts that could interfere with panic handling or exacerbate system instability.
2.  **Video Mode Initialization:** The screen is cleared and filled with red (`#FF0000`), signaling a critical error. All subsequent text data is displayed on this background. If the framebuffer is unavailable, the system simply halts (`hlt`).
3.  **Display Basic Information:** The title `!!! KERNEL PANIC !!!` and the main error message passed to the `panic()` function are displayed on the screen.
4.  **Gather and Display Diagnostic Information:** The system collects and displays the most detailed information about its state at the time of the crash. (See Section 5).
5.  **Halt System:** After displaying all information, the kernel enters an infinite loop `for(;;) { __asm__ __volatile__("cli; hlt"); }`. The `hlt` instruction stops the CPU until the next interrupt. Since interrupts are disabled, this leads to a complete and final system halt.

## 5. Diagnostic Output

The KyroOS panic screen is designed to provide the maximum amount of debugging information.

### 5.1. Screen Structure
The screen is conceptually divided into several areas:

-   **Top Left:** Primary panic message.
-   **Top Right:** General system information.
-   **Central Area:** Detailed error information, including register dumps and log history.
-   **Bottom Right:** QR code (placeholder) with a link to documentation.

### 5.2. Output Content

-   **System Info:**
    -   `KyroOS Version`: Version and build number.
    -   `CPU`: Processor brand and model.
    -   `RAM`: RAM usage (used / total MB).
    -   `Display`: Framebuffer resolution and color depth.
-   **Last Log Messages:**
    -   The last 5 messages recorded via `klog` are displayed. This helps to reconstruct the sequence of events preceding the crash.
-   **Register Dump:**
    -   A full dump of 16 general-purpose 64-bit registers (RAX, RBX, ..., R15).
    -   `RIP`: Instruction pointer at the time of the crash (or the next instruction).
    -   `RSP`: Stack pointer.
    -   `RBP`: Base pointer of the current stack frame.
    -   `RFL` (RFLAGS): Processor flags.
    -   `CS`, `SS`: Code and stack segment selectors.
    -   `INT`: Interrupt (exception) number.
    -   `ERR`: Error code provided by the processor.
-   **Page Fault Details (for #14 only):**
    -   `Faulting Address (CR2)`: The linear address that caused the fault.
    -   **Decoded Error Code:**
        -   `(P)`: Page Not Present / Protection Violation.
        -   `(W/R)`: Read / Write Operation.
        -   `(U/S)`: User / Supervisor Mode.
        -   `(RSVD)`: Reserved Bit Set.
        -   `(I/D)`: Instruction Fetch.
-   **Stack Trace:**
    -   A call chain dump obtained by traversing stack frames, starting from `RBP`. Return addresses (`RIP`) for the last 10 functions in the stack are displayed.

## 6. System Behavior After Panic

After a call to `panic()`, the system is considered inoperable. **Recovery or continued operation is not possible.** The only normal action after displaying the panic screen is a full system reboot or user shutdown. The system remains in a frozen state (`hlt`) until a hardware reset.

## 7. Debug vs Production

In development builds (`Debug`), the `epstein=1` flag may be enabled, which provides additional features, including those for panic debugging:

-   **`panic <reason>` command in shell:** A built-in shell command allows a developer to manually trigger a kernel panic with a custom message. This is useful for testing the panic handler itself and simulating critical errors.

In `Production` builds, this flag should always be disabled, and the ability to manually trigger a panic is removed to ensure system stability and security.

## 8. Examples and Analysis

### Example 1: Page Fault Panic
-   **Scenario:** The kernel attempts to write to a null pointer.
-   **Detection:** The CPU generates a Page Fault exception (#14), as the first memory page is typically unmapped or write-protected.
-   **Diagnostic on Panic Screen:**
    -   **Message:** `Page Fault`
    -   **INT:** `0e` (14)
    -   **ERR:** Error code indicating a `Write Operation` in `Supervisor Mode` to a `Page Not Present`.
    -   **CR2:** `0000000000000000` (or a value close to zero).
    -   **RIP:** Address of the instruction attempting the write.
    -   **Stack Trace:** Helps identify which function performed the incorrect operation.

### Example 2: Assertion Panic
-   **Scenario:** A function expecting a non-null pointer receives `NULL` and checks this via `ASSERT(ptr != NULL)`.
-   **Detection:** The `ASSERT` macro expands to a check. If the condition is false, it calls `panic()`.
-   **Diagnostic on Panic Screen:**
    -   **Message:** "Assertion failed: ptr != NULL at src/kernel/some_file.c:123" (or similar, depending on the `ASSERT` implementation).
    -   **Register Dump & Stack Trace:** Show the context in which the incorrect call was made, allowing the source of the `NULL` to be traced.
    -   `INT` and `ERR` in this case may not be relevant, as the panic is software-initiated.
