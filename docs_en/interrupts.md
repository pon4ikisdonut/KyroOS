# 6. Interrupts and Exceptions

The architecture for handling interrupts and exceptions in KyroOS is fundamental for interacting with hardware, processing errors, and implementing multitasking. It is built upon the Interrupt Descriptor Table (IDT) of the x86-64 architecture.

## 6.1. Handling Architecture

The process of handling an interrupt or exception goes through several stages, from the hardware event to the invocation of high-level C code.

1.  **Event:** The processor (when an exception occurs) or an external device (via the PIC interrupt controller) initiates an interrupt.
2.  **IDT Lookup:** The processor uses the interrupt vector number (0-255) as an index into the IDT to find the corresponding Gate Descriptor.
3.  **Jump to Stub Handler:** The descriptor points to a low-level assembly stub handler (`ISR stub`). In KyroOS, each vector has its own unique stub (`isr0`, `irq0`, etc.).
4.  **Context Saving:** The assembly stub immediately saves the full context of the interrupted thread onto the stack: all general-purpose registers, as well as `RIP`, `CS`, `RFLAGS`, `RSP`, `SS` (the latter are saved automatically by the processor). The saved data forms the `struct registers`.
5.  **Call C Dispatcher:** The stub calls a common C function, `isr_handler()`, passing it a pointer to the context saved on the stack (`struct registers*`).
6.  **High-Level Processing:** The C dispatcher analyzes the interrupt number and transfers control to the appropriate handler (e.g., keyboard driver or scheduler).
7.  **Return:** After the C handler completes its work, control returns to the assembly stub, which restores all saved registers and executes the `iretq` instruction. This instruction atomically restores `RIP`, `CS`, `RFLAGS`, and other registers, returning control to the interrupted code.

### IDT Setup (`idt_init`)

During kernel initialization, the `idt_init` function creates and loads the IDT:
-   A descriptor is created for each of the 256 vectors.
-   **Vectors 0-31** are linked to **CPU exception** handlers.
-   **Vectors 32-47** are linked to **hardware interrupt (IRQ)** handlers from the PIC controller.
-   **Vector 128 (0x80)** is linked to the **system call** handler.
-   An Interrupt Gate (type `0x8E`) is used for kernel gates, and a Trap Gate (type `0xEE`) is used for system calls, allowing it to be called from user space (Ring 3).

### IRQ Dispatching

For hardware interrupts (keyboard, mouse, disks), a registration mechanism is used. Drivers can register their handler function for a specific IRQ number using `register_irq_handler()`. When the `isr_handler` C dispatcher receives an IRQ, it finds and calls the corresponding registered handler.

## 6.2. Timers

The system timer is a key component for implementing preemptive multitasking.
-   **Device:** KyroOS uses the standard Programmable Interval Timer (PIT).
-   **Initialization (`timer_init`):** The kernel programs the PIT to generate an **IRQ 0** interrupt at **100 Hz**.
-   **Handling:** The IRQ 0 handler increments a global tick counter (`ticks`) and, most importantly, calls the `schedule()` function. This periodic invocation of the scheduler ensures task switching and the illusion of parallel execution.

## 6.3. CPU Exceptions

Exceptions are events generated by the processor when an erroneous situation is detected. In KyroOS, the handling of exceptions occurring in kernel mode is implemented as safely as possible: any such error is considered fatal and leads to a **Kernel Panic**.

The `isr_handler` dispatcher for vectors 0-31:
1.  Determines the exception type by its number.
2.  Finds the corresponding descriptive text (e.g., "Page Fault", "General Protection Fault").
3.  Calls the `panic()` function, passing it this description and the full register dump (`struct registers*`) saved on the stack.

This approach does not attempt to recover the system after a kernel crash, but instead provides the most comprehensive diagnostic information for debugging.

## 6.4. Fault and Trap

In the x86-64 architecture, interrupts and exceptions are divided into several types. KyroOS uses two of them:

-   **Fault:** This is a type of exception reported *before* the execution of the instruction that caused the error. The return address (`RIP`) saved on the stack points to the faulty instruction itself. This allows the handler to potentially fix the cause (e.g., load a page during a Page Fault) and re-execute the instruction. Page Fault and General Protection Fault exceptions are examples of Faults.

-   **Trap:** This is a type of exception reported *after* the execution of the instruction. The return address points to the instruction *following* the one that caused the Trap. This is used for debugging (int3 breakpoints) and system calls. In KyroOS, system calls via `int 0x80` are implemented as Traps, allowing the user program to continue execution after the kernel completes its work.
