# 8. IPC и синхронизация

## 8.1. Механизмы IPC

Inter-Process Communication (IPC) в KyroOS находится на начальном этапе развития. На данный момент реализован один основной механизм.

### 8.1.1. Sockets (Сокеты)

Сокеты являются основным средством межпроцессного взаимодействия в KyroOS. Реализация сетевого стека, включающая TCP и UDP, позволяет процессам обмениваться данными как по сети, так и локально через интерфейс loopback. Это стандартный и гибкий механизм, позволяющий реализовать клиент-серверные архитектуры.

### 8.1.2. Shared Memory (Разделяемая память)

**Assumed Design:** В системе отсутствует явный API для создания сегментов разделяемой памяти (как, например, `shm_open` в POSIX). Однако архитектура VMM позволяет реализовать этот механизм. Потоки, принадлежащие одному логическому процессу (т.е. использующие одно и то же адресное пространство `pml4`), по умолчанию разделяют всю память, что является формой неявной разделяемой памяти.

### 8.1.3. Pipes (Каналы)

Каналы (`pipes`) в данный момент **не реализованы**. Их добавление планируется в будущих версиях.

## 8.2. Примитивы синхронизации

На текущем этапе разработки в KyroOS отсутствуют высокоуровневые примитивы синхронизации, такие как мьютексы, семафоры или спинлоки.

### 8.2.1. Отключение прерываний

Единственным используемым механизмом синхронизации внутри ядра является глобальное отключение и включение прерываний (`disable_interrupts()` / `enable_interrupts()`).

- **Применение:** Этот метод используется для защиты критических секций очень малой длины, где необходимо обеспечить атомарность операций относительно аппаратных прерываний. Примерами являются модификация очередей планировщика или общей событийной очереди.
- **Ограничения:**
    - Это очень "тяжелый" и грубый механизм, который останавливает всю активность в системе, включая тики таймера.
    - Он **не решает проблему синхронизации на многоядерных системах** (которые в данный момент не поддерживаются), так как `cli` действует только на том ядре, где была вызвана.
    - Данный механизм не может использоваться для длительного ожидания ресурса, так как это полностью "замораживает" систему.

### 8.2.2. Блокировка потоков

**Assumed Design:** Состояние потока `THREAD_BLOCKED` существует, и планировщик умеет его обрабатывать (он не выбирает заблокированные потоки для выполнения). Однако, судя по комментариям в коде (`TODO: proper thread blocking/unblocking`), полноценный механизм, который бы переводил поток в состояние `BLOCKED` при ожидании ресурса и пробуждал (`READY`) при его освобождении, еще **не реализован**.

## 8.3. Модель, управляемая событиями

В ядре KyroOS реализована простая модель, управляемая событиями, которая используется преимущественно для обработки ввода.

### событийная очередь (`Event Queue`)

- **Архитектура:** Реализована как глобальная, статическая **кольцевая очередь (circular buffer)** фиксированного размера (256 событий).
- **Структура события (`event_t`):** Каждое событие содержит тип (`EVENT_KEY_DOWN`, `EVENT_MOUSE_MOVE` и т.д.) и до трех целочисленных полей с данными (например, скан-код клавиши или координаты мыши).
- **Производители (Producers):** Обработчики прерываний от устройств ввода (клавиатуры, мыши) являются производителями событий. При получении данных от устройства они формируют `event_t` и помещают его в хвост очереди с помощью `event_push()`.
- **Потребители (Consumers):** Пользовательские приложения являются потребителями. Они могут запрашивать события из головы очереди с помощью системного вызова `SYS_INPUT_POLL_EVENT`, который внутри ядра вызывает `event_pop()`.
- **Синхронизация:** Доступ к очереди (изменение указателей `head`/`tail` и счетчика `event_count`) защищен через `disable_interrupts()`, что обеспечивает потокобезопасность в контексте одноядерной системы.
