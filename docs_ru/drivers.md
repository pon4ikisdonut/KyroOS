# 10. Драйверная модель

KyroOS использует гибридную драйверную модель, сочетающую в себе динамическое обнаружение для современных шин и статическую инициализацию для устаревшего оборудования.

## 10.1. Архитектура драйверов

В основе современной части драйверной модели лежат три компонента:
-   **Device (`device_t`):** Структура, представляющая одно аппаратное устройство, обнаруженное в системе. Содержит идентификационную информацию (например, Vendor/Device ID для PCI-устройств), а также указатель на привязанный к нему драйвер.
-   **Driver (`driver_t`):** Структура, представляющая драйвер. Содержит имя драйвера и указатели на ключевые функции:
    -   `probe()`: Проверяет, может ли данный драйвер работать с указанным устройством.
    -   `attach()`: Инициализирует устройство и "привязывает" к нему драйвер.
    -   `detach()`: Освобождает ресурсы и отключает устройство.
-   **Device Manager (`deviceman`):** Центральный компонент, который выступает в роли реестра. Он хранит список всех зарегистрированных в системе драйверов и список всех обнаруженных устройств.

## 10.2. Инициализация устройств

Процесс инициализации для современных PCI-устройств проходит в несколько этапов:

1.  **Обнаружение (Discovery):** На этапе загрузки ядра вызывается функция `pci_check_all_buses()`, которая сканирует шину PCI. Для каждого найденного устройства она создает структуру `device_t` и регистрирует ее в Device Manager с помощью `deviceman_register_device()`.
2.  **Регистрация драйверов:** Каждый драйвер для PCI-устройств (например, `e1000.c`) имеет функцию инициализации (`e1000_driver_init()`), которая вызывается из `kmain`. Эта функция регистрирует сам драйвер (его структуру `driver_t`) в Device Manager через `deviceman_register_driver()`.
3.  **Сопоставление (Probe/Attach):** После того как все устройства обнаружены и все драйверы зарегистрированы, вызывается функция `deviceman_probe_devices()`. Она выполняет следующую логику:
    -   Для каждого устройства из списка обнаруженных...
    -   ...она перебирает все драйверы из списка зарегистрированных.
    -   Вызывается `driver->probe(device)`. Если функция возвращает `true` (драйвер подходит),...
    -   ...то вызывается `driver->attach(device)`. Если `attach` завершается успешно, устройство и драйвер связываются, и процесс переходит к следующему устройству.

### Инициализация устаревших устройств

Для не-обнаруживаемого оборудования, такого как PS/2 клавиатура или системный таймер (PIT), используется более простая статическая модель. Их функции инициализации (например, `keyboard_init()`) вызываются напрямую из `kmain`. Эти функции вручную настраивают порты ввода-вывода и регистрируют свои обработчики прерываний для соответствующих номеров IRQ.

## 10.3. Поддерживаемые шины

-   **PCI (Peripheral Component Interconnect):** Основная шина для обнаружения и настройки современных устройств, таких как сетевые карты и дисковые контроллеры. Ядро содержит полноценный PCI-сканер.
-   **ISA (Legacy):** Устаревшие устройства, такие как клавиатура, мышь и таймер, управляются напрямую через порты ввода-вывода (I/O Ports).

## 10.4. Взаимодействие с ядром

Драйверы являются неотъемлемой частью ядра и взаимодействуют с другими подсистемами различными способами:

-   **Регистрация в Device Manager:** Как описано выше, это основной способ для PCI-драйверов заявить о себе.
-   **Регистрация обработчиков прерываний:** Драйверы вызывают `register_irq_handler()` для привязки своей функции к определенному IRQ. Эта функция будет вызываться каждый раз при возникновении аппаратного прерывания от устройства.
-   **Выделение памяти:** Драйверы используют `kmalloc()` для выделения памяти под свои внутренние структуры и `pmm_alloc_page()` для выделения страниц под DMA-буферы.
-   **Взаимодействие с VFS:** Драйверы блочных устройств (например, IDE) могут предоставлять свои функции `read`, `write`, `ioctl` и регистрировать `vfs_node_t` в файловой системе (например, `/dev/hda`). Это позволяет пользовательскому пространству взаимодействовать с устройством через стандартные файловые операции.
-   **Взаимодействие с сетевым стеком:** Сетевые драйверы (например, `e1000`) регистрируют себя в сетевой подсистеме (`net_register_device()`), предоставляя функцию для отправки пакетов. При получении пакета обработчик прерывания драйвера передает данные вверх по сетевому стеку (например, в обработчик IP или ARP).
-   **Очередь событий:** Драйверы устройств ввода (клавиатура, мышь) не взаимодействуют с VFS напрямую. Вместо этого они генерируют события (`event_t`) и помещают их в глобальную очередь событий, откуда их могут читать приложения через системный вызов `SYS_INPUT_POLL_EVENT`.
