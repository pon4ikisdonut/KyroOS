# 11. Графическая подсистема

Графическая подсистема в KyroOS спроектирована по простой и прямой модели, предоставляющей пользовательским приложениям непосредственный доступ к оборудованию. В ядре отсутствуют сложные компоненты, такие как графический сервер или композитор окон.

## 11.1. Framebuffer и модель доступа

Основой всей графической подсистемы является **линейный framebuffer**.

### Инициализация

При загрузке ядро получает от загрузчика Limine информацию о видеорежиме, установленном прошивкой. Эта информация включает в себя:
-   Физический адрес начала framebuffer.
-   Разрешение экрана (ширина и высота в пикселях).
-   `pitch` (количество байт в одной строке экрана).
-   Глубину цвета (`bpp` - bits per pixel).

На основе этих данных инициализируется низкоуровневый драйвер `fb.c`.

### Двойная буферизация

Для предотвращения мерцания и разрывов изображения (`tearing`) при отрисовке, драйвер `fb.c` реализует **двойную буферизацию**:
1.  При инициализации в памяти ядра создается теневой буфер (`backbuffer`) того же размера, что и видимый framebuffer.
2.  Все низкоуровневые операции отрисовки (`fb_put_pixel`, `fb_draw_rect`, `fb_draw_char`) производятся в этом теневом буфере.
3.  После завершения формирования кадра вызывается функция `fb_flush()`, которая атомарно копирует все содержимое `backbuffer` в видимый framebuffer.

### Модель доступа для пользовательского пространства

KyroOS не использует модель клиент-сервер (как X11) для графики. Вместо этого она предоставляет пользовательским приложениям **прямой доступ к видеопамяти**:
1.  Приложение вызывает системный вызов `SYS_GFX_GET_FB_INFO`.
2.  В ответ ядро отображает физические страницы видимого framebuffer напрямую в виртуальное адресное пространство вызывающего процесса.
3.  Приложению возвращаются разрешение экрана и виртуальный адрес, по которому теперь доступен framebuffer.
4.  С этого момента приложение может рисовать что угодно, просто записывая данные в этот участок своей памяти.

**Преимущества:**
-   Максимальная производительность, так как отсутствуют посредники и переключения контекста при отрисовке.

**Недостатки:**
-   Отсутствие защиты: любое приложение может испортить любую часть экрана.
-   Вся логика отрисовки виджетов, управления окнами и их композиции должна быть реализована в библиотеках пользовательского пространства.

### Ускорение GPU

На данный момент **аппаратное ускорение GPU не используется**. Все операции отрисовки выполняются программно центральным процессором.

## 11.2. Оконная система

В KyroOS **отсутствует оконная система (windowing system) на уровне ядра**. Ядро не имеет понятий "окно", "виджет" или "рабочий стол".

### Внутренний GUI-тулкит

В коде ядра (`gui.c`) присутствует рудиментарный графический инструментарий. Он позволяет создавать простые окна и отрисовывать их. Однако этот компонент **недоступен из пользовательского пространства** и используется исключительно для внутренних нужд ядра (например, для отладочных экранов или будущих TUI-инсталляторов, работающих в режиме ядра).

## 11.3. Устройства ввода

Взаимодействие с устройствами ввода полностью отделено от процесса отрисовки.
1.  **Драйверы:** Драйверы клавиатуры и мыши являются обработчиками прерываний (IRQ).
2.  **Очередь событий:** При получении данных от устройства (нажатие клавиши, движение мыши) драйвер не рисует ничего на экране. Вместо этого он формирует структуру `event_t` и помещает ее в глобальную, централизованную **очередь событий**.
3.  **Опрос из Userspace:** Графические приложения в своем цикле работы периодически вызывают системный вызов `SYS_INPUT_POLL_EVENT`, чтобы извлечь следующее событие из очереди.
4.  **Реакция:** Получив событие (например, `EVENT_MOUSE_MOVE`), приложение само решает, как на него реагировать (например, перерисовать курсор в новом месте).
