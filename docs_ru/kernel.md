# 4. Ядро (Kernel)

## 4.1. Структура ядра

Ядро KyroOS имеет **монолитную** архитектуру. Это означает, что все основные компоненты — управление памятью, планировщик задач, файловая система, сетевой стек и драйверы устройств — находятся в одном адресном пространстве и выполняются на уровне привилегий Ring 0.

### Структура исходного кода

Исходный код ядра организован в следующих ключевых директориях:
- `src/kernel/`: Основная логика подсистем ядра (C-файлы).
- `src/boot/`: Низкоуровневый ассемблерный код для загрузки и переключения контекста.
- `src/include/`: Заголовочные файлы для всех подсистем, определяющие API и структуры данных.

### Основные компоненты

Ядро состоит из тесно интегрированных, но логически разделенных компонентов:
- **Менеджер физической памяти (PMM):** Отвечает за учет и распределение страниц физической памяти.
- **Менеджер виртуальной памяти (VMM):** Управляет адресными пространствами процессов, таблицами страниц и обеспечивает изоляцию памяти.
- **Планировщик (Scheduler):** Реализует многозадачность, переключая контекст между потоками.
- **Системные вызовы (Syscall):** Механизм, через который пользовательские приложения запрашивают сервисы у ядра.
- **Виртуальная файловая система (VFS):** Абстрактный слой для работы с различными файловыми системами.
- **Драйверы:** Модули, управляющие конкретными аппаратными устройствами (клавиатура, таймер, IDE, E1000).

## 4.2. Планировщик задач

Планировщик отвечает за реализацию вытесняющей многозадачности.

### Алгоритм

Используется классический алгоритм **Round-Robin** (циклический или "карусельный"). Каждому готовому к выполнению потоку выделяется определенный квант времени. Если поток не завершается и не блокируется за этот квант, он принудительно прерывается, и процессор передается следующему потоку в очереди.

### Квант времени

Системный таймер настроен на генерацию прерывания с частотой **100 Гц**. Это означает, что планировщик вызывается каждые **10 миллисекунд**, что и является квантом времени для каждого потока.

### Структура данных

Все потоки в системе организованы в виде **односвязного циклического списка** (`ready_queue`). Указатель `ready_queue` ссылается на "хвост" очереди. Соответственно, `ready_queue->next` является "головой" очереди — следующим кандидатом на выполнение.

### Логика работы (`schedule()`)

Функция `schedule()` вызывается обработчиком прерывания таймера. Ее логика следующая:
1.  Отключаются прерывания для обеспечения атомарности операции.
2.  Планировщик ищет в циклическом списке следующий поток в состоянии `THREAD_READY`.
3.  Во время поиска он выполняет "сборку мусора": если встречается поток в состоянии `THREAD_DEAD`, планировщик освобождает все выделенные ему ресурсы (стек ядра, стек пользователя, таблицы страниц) и удаляет его из списка.
4.  Если текущий выполняемый поток (`current_thread`) переходит в состояние `THREAD_READY` (его квант времени истек), он остается в списке для последующего выполнения.
5.  Найденный следующий поток для выполнения помечается как `THREAD_RUNNING`.
6.  Если был найден новый поток для выполнения, отличный от предыдущего, вызывается низкоуровневая функция `thread_switch()` для выполнения переключения контекста.

## 4.3. Процессы и потоки

В KyroOS основной единицей планирования является **поток** (`thread_t`). Понятие **процесса** является логической абстракцией и не представлено отдельной структурой. Процесс — это совокупность одного или нескольких потоков, которые выполняются в общем виртуальном адресном пространстве и разделяют общие ресурсы.

### Структура `thread_t`
Ключевые поля структуры `thread_t` (`src/include/thread.h`):
- `id`: Уникальный идентификатор потока.
- `state`: Текущее состояние (`THREAD_RUNNING`, `THREAD_READY`, `THREAD_BLOCKED`, `THREAD_DEAD`).
- `stack`: Указатель на вершину стека ядра данного потока.
- `user_stack_base`: Указатель на основание стека в пользовательском пространстве.
- `rsp`: Сохраненное значение регистра `RSP` (указателя стека ядра) в момент, когда поток был прерван.
- `pml4`: Указатель на таблицу страниц верхнего уровня (PML4), которая определяет виртуальное адресное пространство потока. Потоки одного процесса разделяют один и тот же `pml4`.
- `fd_table`: Собственная таблица файловых дескрипторов.
- `next`: Указатель на следующий поток в циклическом списке планировщика.

## 4.4. Контекстное переключение

Переключение контекста — это низкоуровневая операция сохранения состояния одного потока и восстановления состояния другого. Она реализована в ассемблерной функции `thread_switch` (`src/boot/switch.asm`).

### Процедура `thread_switch(old_thread, new_thread)`

1.  **Сохранение регистров `old_thread`:**
    *   Регистры `rbp`, `rbx`, `r12`, `r13`, `r14`, `r15` (callee-saved) сохраняются в текущем стеке ядра.
    *   Указатель инструкций (`rip`) неявно сохраняется на стеке инструкцией `call`, которая привела к вызову планировщика.
2.  **Сохранение указателя стека:** Текущее значение регистра `rsp` сохраняется в структуре старого потока: `old_thread->rsp = rsp`.
3.  **Переключение адресного пространства:**
    *   Происходит сравнение указателей `pml4` старого и нового потоков.
    *   **Если указатели отличаются**, это означает переключение между разными процессами. В таком случае физический адрес `pml4` нового потока загружается в регистр `CR3`. Это атомарно переключает все виртуальное адресное пространство.
    *   **Если указатели совпадают**, переключение `CR3` не требуется, так как потоки принадлежат одному процессу.
4.  **Восстановление контекста `new_thread`:**
    *   Значение указателя стека восстанавливается из структуры нового потока: `rsp = new_thread->rsp`.
    *   Регистры `rbp`, `rbx` и т.д. восстанавливаются со стека нового потока в обратном порядке.
5.  **Возврат из функции:** Инструкция `ret` снимает со стека сохраненный ранее `rip` нового потока и совершает переход по этому адресу. С этого момента начинает выполняться новый поток с того места, где он был прерван.