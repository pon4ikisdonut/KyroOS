# 3. Загрузка системы

## 3.1. Цепочка загрузки (Boot Chain)

KyroOS использует современный загрузчик [Limine](https://github.com/limine-bootloader/limine), который поддерживает как устаревшие системы с BIOS, так и современные с UEFI. Процесс загрузки состоит из нескольких последовательных этапов, передающих управление от прошивки компьютера ядру операционной системы.

**Общая последовательность:**

1.  **Прошивка (BIOS/UEFI):** Выполняет инициализацию базового оборудования (Power-On Self-Test, POST) и, согласно своим настройкам, находит загрузочный сектор на загрузочном носителе (например, ISO-образе).
2.  **Загрузчик Limine:** Прошивка передает управление загрузчику Limine. Limine сканирует файловую систему носителя, находит и читает конфигурационный файл `limine.conf`.
3.  **Загрузка ядра:** Следуя инструкциям из `limine.conf`, Limine загружает в оперативную память основной файл ядра (`/boot/kernel.elf`) и указанные в конфигурации файлы-модули (например, утилиты пользовательского пространства).
4.  **Передача управления ядру:** Limine подготавливает окружение (устанавливает 64-битный режим, формирует карту памяти и т.д.) и передает управление на точку входа ядра, определенную в ELF-файле.

## 3.2. Этапы загрузки ядра

Процесс инициализации самого ядра делится на два основных этапа: низкоуровневая подготовка на ассемблере и высокоуровневая инициализация подсистем на языке C.

### Этап 1: Низкоуровневая инициализация (`_start` в `src/boot/boot.asm`)

Сразу после получения управления от Limine, процессор начинает выполнение кода с метки `_start`. На этом этапе выполняются критически важные первоначальные действия:

1.  **Отключение прерываний:** Первой же инструкцией является `cli`. Это предотвращает возникновение любых аппаратных прерываний, пока система не будет готова их обрабатывать (т.е. пока не будет настроена IDT и обработчики).
2.  **Установка стека:** Настраивается указатель стека (`rsp`) на предварительно выделенную в BSS-секции область памяти. Это необходимо для корректной работы вызовов функций.
3.  **Вызов C-кода:** Выполняется инструкция `call kmain_x64`, которая передает управление основной функции инициализации ядра, написанной на C.

На этом работа ассемблерного кода завершается. Его единственная задача — создать минимально необходимое окружение для запуска C-функций.

### Этап 2: Высокоуровневая инициализация (`kmain_x64` в `src/kernel/kernel.c`)

Функция `kmain_x64` является точкой входа в высокоуровневую часть ядра и выполняет последовательную инициализацию всех ключевых подсистем. Порядок инициализации строго определен и критически важен для корректного запуска системы.

1.  **Инициализация логирования (`log_init`):** Запускается подсистема логирования, позволяющая выводить отладочную информацию через последовательный порт.
2.  **Инициализация Framebuffer (`fb_init`):** На основе информации, полученной от Limine, настраивается видео-буфер для вывода графики и текста на экран.
3.  **Инициализация управления памятью:**
    *   **PMM (`pmm_init`):** Инициализируется менеджер физической памяти, который получает карту доступной памяти от Limine и создает структуру для учета свободных и занятых страниц.
    *   **Heap (`heap_init`):** На основе PMM создается ядровая куча для динамического выделения памяти (`kmalloc`, `kfree`).
    *   **VMM (`vmm_init`):** Инициализируется менеджер виртуальной памяти. Создаются и загружаются таблицы страниц (PML4) для адресного пространства ядра.
4.  **Настройка структур процессора:**
    *   **GDT (`gdt_init`):** Загружается новая Global Descriptor Table, содержащая сегменты для кода и данных ядра и пользовательского пространства.
    *   **IDT (`idt_init`):** Загружается Interrupt Descriptor Table с обработчиками исключений процессора и аппаратных прерываний.
    *   **TSS (`tss_init`):** Инициализируется Task State Segment, используемый для переключений стека при смене уровня привилегий.
5.  **Инициализация базовых драйверов:**
    *   **Клавиатура (`keyboard_init`):** Настраивается драйвер для обработки ввода с клавиатуры.
    *   **Таймер (`timer_init`):** Программируется прерывание от системного таймера (обычно с частотой 100 Гц), которое будет использоваться планировщиком.
6.  **Инициализация файловой системы:**
    *   **VFS (`vfs_init`):** Запускается слой виртуальной файловой системы, предоставляющий унифицированный API для работы с файлами.
    *   **KyroFS (`kyrofs_init`):** Инициализируется и монтируется корневая файловая система (in-memory).
    *   **Загрузка модулей:** Файлы, загруженные Limine как модули, с помощью VFS помещаются в файловую систему KyroFS (например, в директорию `/bin/`).
7.  **Инициализация устройств и драйверов:**
    *   **Device Manager (`deviceman_init`):** Запускается менеджер устройств.
    *   **PCI (`pci_check_all_buses`):** Производится сканирование шины PCI для обнаружения подключенных устройств.
    *   **Сетевой стек:** Последовательно инициализируются все уровни сетевого стека (E1000, ARP, IP, UDP, TCP, DHCP).
8.  **Запуск многозадачности:**
    *   **Потоки (`thread_init`):** Инициализируется подсистема управления потоками.
    *   Создается первый поток ядра, который начинает выполнение основной функции пользовательской оболочки (`shell_main`).
9.  **Включение прерываний:** Выполняется инструкция `sti`. С этого момента система становится полностью интерактивной: процессор начинает реагировать на прерывания от таймера (запуская планировщик) и устройств ввода.

После выполнения `sti`, функция `kmain_x64` фактически завершает свою работу, и управление системой полностью переходит к планировщику и обработчикам прерываний.