# Kernel Panic

## 1. Определение

**Kernel Panic** — это механизм обработки критических ошибок в ядре KyroOS. Данное состояние возникает при обнаружении невосстановимой ошибки, которая ставит под угрозу целостность системы и данных. Когда ядро входит в состояние паники, оно немедленно прекращает нормальное выполнение всех процессов, сохраняет максимальный объем диагностической информации для последующего анализа и останавливает систему, чтобы предотвратить дальнейшие повреждения.

Основная цель механизма — не восстановление работы, а безопасная остановка с предоставлением исчерпывающей информации для отладки.

## 2. Классификация причин

Причины, приводящие к Kernel Panic, делятся на две основные категории:

### 2.1. Исключения процессора (CPU Exceptions)
Наиболее частая причина. Ядро KyroOS перехватывает и обрабатывает исключения, генерируемые CPU. Если исключение происходит в режиме ядра (Ring 0) и не может быть безопасно обработано, инициируется паника.

- **Page Fault (PF, #14):** Попытка доступа к невалидной, отсутствующей или защищенной странице памяти в контексте ядра.
- **General Protection Fault (GPF, #13):** Общее нарушение защиты. Примеры: запись в read-only сегмент кода, выполнение привилегированных инструкций из пользовательского режима (хотя это вызовет панику только при ошибке в ядре), неверные селекторы сегментов.
- **Double Fault (#8) / Triple Fault:** Возникают при невозможности CPU вызвать обработчик для предыдущего исключения. Triple Fault является фатальным на уровне архитектуры и приводит к сбросу системы, но Double Fault перехватывается ядром и вызывает панику.
- **Invalid Opcode (UD, #6):** Попытка выполнения некорректной или привилегированной инструкции.
- **Division by Zero (DE, #0):** Целочисленное деление на ноль.

### 2.2. Программные проверки (Software Assertions)
Ядро содержит внутренние проверки целостности (assertions) для верификации инвариантов и критических условий во время выполнения. Если проверка проваливается, это указывает на логическую ошибку в коде ядра.

- **Kernel Assertions:** `ASSERT(condition)` макросы, которые вызывают панику, если `condition` ложно. Например, проверка валидности указателя перед его использованием.
- **Драйверные ошибки:** Критические ошибки в драйверах устройств (например, отказ оборудования, который не может быть обработан).
- **Повреждение структур данных ядра:** Обнаружение повреждений в ключевых структурах, таких как таблицы процессов, аллокаторы памяти или системные списки.
- **Ошибки инициализации:** Невозможность инициализировать критически важный компонент системы во время загрузки.

## 3. Механизм обнаружения

Обнаружение критических ошибок реализовано на двух уровнях:

1.  **Аппаратный уровень:** Настройка таблиц прерываний (IDT). Для каждого исключения CPU, которое считается критическим для ядра, соответствующий шлюз в IDT настроен на вызов общего обработчика исключений. Этот обработчик сохраняет состояние процессора и вызывает процедуру паники.
2.  **Программный уровень:** Явные вызовы функции `panic()` из кода ядра. Эта функция вызывается в местах, где программная логика обнаруживает фатальное состояние, например, при неудачной проверке `ASSERT` или при невозможности аллоцировать критически важный ресурс.

## 4. Процедура обработки

При обнаружении критической ошибки запускается следующая последовательность действий, реализованная в функции `panic_screen_show()` (`src/kernel/panic_screen.c`):

1.  **Остановка прерываний:** Выполняется инструкция `cli`, чтобы предотвратить любые другие прерывания, которые могут помешать обработке паники или усугубить нестабильность системы.
2.  **Инициализация видеорежима:** Экран очищается и заливается красным цветом (`#FF0000`), сигнализируя о критической ошибке. Все последующие текстовые данные выводятся на этом фоне. Если framebuffer недоступен, система просто останавливается (`hlt`).
3.  **Вывод основной информации:** На экран выводится заголовок `!!! KERNEL PANIC !!!` и основное сообщение об ошибке, переданное в функцию `panic()`.
4.  **Сбор и вывод диагностической информации:** Система собирает и отображает максимально подробную информацию о своем состоянии в момент сбоя. (См. раздел 5).
5.  **Остановка системы:** После вывода всей информации ядро входит в бесконечный цикл `for(;;) { __asm__ __volatile__("hlt"); }`. Инструкция `hlt` останавливает CPU до следующего прерывания. Поскольку прерывания отключены, это приводит к полной и окончательной остановке системы.

## 5. Диагностический вывод

Экран паники KyroOS спроектирован для предоставления максимального количества отладочной информации.

### 5.1. Структура экрана
Экран условно разделен на несколько областей:

- **Верхний левый угол:** Основное сообщение о причине паники.
- **Верхний правый угол:** Общая системная информация.
- **Центральная область:** Детальная информация об ошибке, включая дампы регистров и логов.
- **Нижний правый угол:** QR-код (заглушка) со ссылкой на документацию.

### 5.2. Содержимое вывода

- **System Info:**
    - `KyroOS Version`: Версия и номер сборки.
    - `CPU`: Бренд и модель процессора.
    - `RAM`: Использование оперативной памяти (used / total MB).
    - `Display`: Разрешение и глубина цвета framebuffer.
- **Last Log Messages:**
    - Отображаются последние 5 сообщений, записанных через `klog`. Это помогает восстановить последовательность событий, предшествовавших сбою.
- **Register Dump:**
    - Полный дамп 16 основных 64-битных регистров общего назначения (RAX, RBX, ..., R15).
    - `RIP`: Указатель на инструкцию, вызвавшую сбой (или следующую за ней).
    - `RSP`: Указатель на вершину стека.
    - `RBP`: Указатель на базу текущего стекового фрейма.
    - `RFL` (RFLAGS): Флаги процессора.
    - `CS`, `SS`: Селекторы сегментов кода и стека.
    - `INT`: Номер прерывания (исключения).
    - `ERR`: Код ошибки, предоставленный процессором.
- **Page Fault Details (только для #14):**
    - `Faulting Address (CR2)`: Линейный адрес, доступ к которому вызвал сбой.
    - **Декодированный код ошибки:**
        - `(P)`: Page Not Present / Protection Violation.
        - `(W/R)`: Read / Write Operation.
        - `(U/S)`: User / Supervisor Mode.
        - `(RSVD)`: Reserved Bit Set.
        - `(I/D)`: Instruction Fetch.
- **Stack Trace:**
    - Вывод цепочки вызовов путем обхода стековых фреймов, начиная с `RBP`. Отображаются адреса возврата (`RIP`) для последних 10 функций в стеке.

## 6. Поведение системы после паники

После вызова `panic()` система считается неработоспособной. **Восстановление или продолжение работы невозможно.** Единственное штатное действие после отображения экрана паники — полная перезагрузка или выключение системы пользователем. Система остается в замороженном состоянии (`hlt`) до аппаратного сброса.

## 7. Debug vs Production

В сборках для разработки (`Debug`) может быть включен флаг `epstein=1`, который предоставляет дополнительные возможности, в том числе и для отладки паники:

- **Команда `panic <reason>`:** Встроенная в shell команда позволяет вручную инициировать панику с заданным сообщением. Это используется для тестирования работы самого обработчика паники и для симуляции сбоев.

В `Production` сборках этот флаг должен быть всегда отключен, и возможность вручную вызвать панику отсутствует для обеспечения стабильности и безопасности.

## 8. Примеры и разборы

### Пример 1: Паника из-за Page Fault
- **Сценарий:** Ядро пытается выполнить запись по нулевому указателю.
- **Обнаружение:** CPU генерирует исключение Page Fault (#14), так как первая страница памяти обычно не отображена или защищена от записи.
- **Диагностика на экране паники:**
    - **Message:** `Page Fault`
    - **INT:** `0e` (14)
    - **ERR:** Код ошибки, указывающий на `Write Operation` в `Supervisor Mode` к `Page Not Present`.
    - **CR2:** `0000000000000000` (или близкое к нулю значение).
    - **RIP:** Адрес инструкции, пытавшейся выполнить запись.
    - **Stack Trace:** Поможет определить, какая функция выполнила неверную операцию.

### Пример 2: Паника по Assertion
- **Сценарий:** Функция, ожидающая на вход ненулевой указатель, получает `NULL` и проверяет это через `ASSERT(ptr != NULL)`.
- **Обнаружение:** Макрос `ASSERT` разворачивается в проверку. При ложном условии он вызывает `panic()`.
- **Диагностика на экране паники:**
    - **Message:** "Assertion failed: ptr != NULL at src/kernel/some_file.c:123" (или похожее, в зависимости от реализации `ASSERT`).
    - **Register Dump & Stack Trace:** Показывают контекст, в котором был сделан некорректный вызов, позволяя отследить источник `NULL`.
    - `INT` и `ERR` в этом случае могут не иметь значения, так как паника инициирована программно.
