# 12. Пользовательское пространство (Userspace)

Пользовательское пространство в KyroOS — это среда с низким уровнем привилегий (Ring 3), в которой выполняются все прикладные программы. Оно полностью изолировано от ядра и от других процессов. Взаимодействие с ядром и системными ресурсами осуществляется исключительно через API системных вызовов.

## 12.1. Формат исполняемых файлов

KyroOS использует стандартный, широко распространенный формат исполняемых файлов **ELF64 (Executable and Linkable Format, 64-bit)**.

-   **Спецификация:** Ядро содержит загрузчик, способный парсить заголовки ELF64 (`Elf64_Ehdr`) и заголовки программ (`Elf64_Phdr`).
-   **Тип:** Загрузчик поддерживает только исполняемые файлы (`ET_EXEC`). Релоцируемые (`ET_REL`) и разделяемые (`ET_DYN`) объектные файлы не поддерживаются.
-   **Сборка:** Пользовательские приложения должны быть статически скомпонованы и слинкованы для выполнения по фиксированным виртуальным адресам в нижней половине адресного пространства.

## 12.2. Загрузка программ

Процесс загрузки и запуска программы инициируется системным вызовом `exec` (или аналогичным) и состоит из следующих шагов:

1.  **Создание адресного пространства:** Ядро создает новое, пустое 4-уровневое страничное отображение (PML4) для нового процесса. Верхняя половина этого пространства (адреса ядра) копируется из шаблона ядра, а нижняя (пользовательская) остается пустой.
2.  **Чтение файла:** Ядро считывает ELF-файл целиком в буфер в своей памяти.
3.  **Анализ ELF:** Загрузчик `elf_load` проверяет корректность ELF-заголовка (магическое число, класс, тип).
4.  **Загрузка сегментов:** Загрузчик проходит по всем заголовкам программ (`Program Headers`).
    -   Для каждого сегмента типа `PT_LOAD` (загружаемый сегмент):
    -   Ядро выделяет необходимое количество физических страниц памяти.
    -   Эти страницы отображаются в виртуальное адресное пространство нового процесса по адресу (`p_vaddr`), указанному в заголовке сегмента.
    -   Устанавливаются флаги защиты страниц (`Read`, `Write`, `Execute`) в соответствии с флагами сегмента. Пользовательский доступ (`PAGE_USER`) всегда разрешен.
    -   Данные сегмента копируются из буфера в новые страницы. Если размер в памяти (`p_memsz`) больше размера в файле (`p_filesz`), остаток (секция `.bss`) заполняется нулями.
5.  **Создание потока:** После успешной загрузки всех сегментов ядро создает новый поток в состоянии `READY` (`thread_create_userspace`). В качестве точки входа для этого потока устанавливается адрес (`e_entry`), указанный в заголовке ELF, а в качестве адресного пространства — новое, только что созданное.
6.  **Запуск:** При следующем вызове планировщика новый поток будет выбран для выполнения и начнет свою работу в пользовательском режиме (Ring 3) с точки входа программы.

## 12.3. API для приложений

Основным и единственным API для взаимодействия приложений с ядром является **интерфейс системных вызовов**. Детали механизма, ABI и полный список вызовов описаны в разделе **[7. Системные вызовы](./syscalls.md)**.

## 12.4. Стандартные библиотеки

Полноценная стандартная библиотека C (`libc`) в KyroOS отсутствует. Вместо этого предоставляется набор небольших специализированных библиотек и самодостаточных оберток для системных вызовов.

### Обертка `syscall()`

Так как центральной `libc` нет, каждое приложение или библиотека, которым необходимо совершать системные вызовы, использует собственную локальную реализацию функции `syscall()`. Это небольшая функция, написанная на встроенном ассемблере (GCC inline assembly), которая выполняет следующие действия:
1.  Помещает номер системного вызова в регистр `rax`.
2.  Помещает аргументы в регистры `rdi`, `rsi`, `rdx` и т.д.
3.  Выполняет инструкцию `int 0x80`.
4.  Возвращает значение из регистра `rax` после завершения вызова.

### `libkyroos_gfx`

Простая графическая библиотека, предоставляющая базовые функции для рисования.
-   **Инициализация:** При инициализации (`gfx_init()`) библиотека вызывает `SYS_GFX_GET_FB_INFO`, чтобы получить от ядра прямой доступ к видеопамяти.
-   **Функционал:** Предоставляет функции `gfx_draw_pixel`, `gfx_draw_rect`, которые напрямую записывают данные в память framebuffer. Также включает обертку для `SYS_INPUT_POLL_EVENT` для получения событий ввода.

### `libtui`

Библиотека для создания текстовых пользовательских интерфейсов (Text User Interface). Является надстройкой более высокого уровня над `libkyroos_gfx`.
-   **Функционал:** Использует полученный от ядра framebuffer для отрисовки текста с помощью встроенного в библиотеку растрового шрифта (`tui_draw_text`), а также для рисования простых графических примитивов вроде прямоугольников (`tui_draw_box`).
-   **Применение:** Используется для создания псевдо-графических оконных интерфейсов без полноценной графической подсистемы.
