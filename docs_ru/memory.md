# 5. Управление памятью

Управление памятью в KyroOS построено на двухуровневой модели, стандартной для современных операционных систем: менеджер физической памяти (PMM) управляет реальными ресурсами ОЗУ, а менеджер виртуальной памяти (VMM) предоставляет изолированные адресные пространства для каждого процесса.

## 5.1. Физическая память (PMM)

Менеджер физической памяти (`Physical Memory Manager`) отвечает за учет, выделение и освобождение страниц физической оперативной памяти.

### Стратегия

PMM использует **битмап (bitmap)** для отслеживания состояния каждой физической страницы в системе. Каждой странице размером 4 КБ соответствует один бит в битмапе: 1 означает, что страница занята, 0 — свободна.

### Инициализация (`pmm_init`)

1.  При загрузке ядро получает от загрузчика Limine карту памяти (`memory map`), в которой перечислены все доступные диапазоны ОЗУ и их типы (usable, reserved, ACPI, etc.).
2.  PMM находит самый большой диапазон в памяти и вычисляет общий объем ОЗУ, а также размер, необходимый для хранения самого битмапа.
3.  Затем он находит в карте памяти первый достаточно большой *свободный* участок и размещает в нем битмап.
4.  Изначально весь битмап заполняется единицами (вся память считается занятой).
5.  Далее PMM проходит по карте памяти еще раз и обнуляет биты для тех страниц, которые Limine пометил как `USABLE` (доступные для использования).
6.  Наконец, биты, соответствующие страницам, на которых расположен сам битмап, снова выставляются в 1, чтобы защитить его от перезаписи.

### Аллокация и освобождение

-   **`pmm_alloc_page()`:** Выполняет линейный поиск в битмапе, начиная с места последней успешной аллокации. Найдя первый свободный бит (0), он выставляет его в 1 и возвращает соответствующий физический адрес страницы. Это простая реализация алгоритма "next-fit".
-   **`pmm_free_page(address)`:** Вычисляет индекс страницы по ее физическому адресу и обнуляет соответствующий бит в битмапе.

## 5.2. Виртуальная память (VMM)

Менеджер виртуальной памяти (`Virtual Memory Manager`) отвечает за создание и управление виртуальными адресными пространствами. Это ключевой механизм, обеспечивающий изоляцию процессов и защиту памяти.

### Архитектура

KyroOS использует **4-уровневую модель страничной адресации (Paging)**, стандартную для архитектуры x86-64. Каждое виртуальное адресное пространство описывается иерархией из четырех таблиц:
1.  Page Map Level 4 (PML4) - Таблица 4-го уровня (корневая)
2.  Page Directory Pointer Table (PDPT) - Таблица указателей каталогов страниц
3.  Page Directory (PD) - Каталог страниц
4.  Page Table (PT) - Таблица страниц

Каждая таблица содержит 512 64-битных записей. Каждая запись в PT указывает на физическую страницу размером 4 КБ.

### Адресное пространство

64-битное виртуальное адресное пространство разделено на две половины:
- **Нижняя половина (User Space):** Адреса от `0x0000000000000000` до `0x00007FFFFFFFFFFF`. Эта часть уникальна для каждого процесса и содержит его код, данные, кучу и стек.
- **Верхняя половина (Kernel Space):** Адреса от `0xFFFF800000000000` и выше. Эта часть одинакова для всех процессов и содержит код и данные ядра, а также прямое отображение всей физической памяти (Higher-Half Direct Map, HHDM).

### Higher-Half Direct Map (HHDM)

Вся физическая память отображается в верхней половине виртуального адресного пространства с постоянным смещением (`hhdm_offset`). Это позволяет ядру иметь прямой доступ к любой физической странице, просто прибавив к ее адресу это смещение. Функции `p_to_v()` (physical-to-virtual) и `v_to_p()` (virtual-to-physical) используются для такого преобразования.

### Создание адресного пространства (`vmm_create_address_space`)

При создании нового процесса:
1.  PMM выделяет одну страницу для новой PML4-таблицы.
2.  Нижняя половина этой таблицы (первые 256 записей), отвечающая за User Space, обнуляется.
3.  **Верхняя половина** (последние 256 записей), отвечающая за Kernel Space, **копируется** из PML4-таблицы ядра.
Таким образом, ядро всегда отображено в каждом процессе, что делает обработку системных вызовов и прерываний очень эффективной, так как не требует смены адресного пространства.

## 5.3. Аллокаторы

### Kernel Heap (`kmalloc`/`kfree`)

Для динамического выделения памяти внутри ядра (например, для создания структур данных) используется аллокатор кучи.

- **Стратегия:** Реализация основана на классическом аллокаторе из книги K&R. Он использует **связный список свободных блоков памяти**.
- **`kmalloc()`:** При запросе на выделение памяти, аллокатор ищет в списке свободных блоков первый подходящий по размеру (first-fit/next-fit). Если блок больше запрошенного, он разбивается на две части.
- **`kfree()`:** Освобождаемый блок добавляется в список свободных. Аллокатор также выполняет **слияние (coalescing)**: если освобождаемый блок граничит с другим свободным блоком, они объединяются в один большой блок для борьбы с фрагментацией.
- **`morecore()`:** Если `kmalloc` не может найти подходящий блок, он вызывает внутреннюю функцию `morecore`, которая запрашивает у PMM одну или несколько новых физических страниц, отображает их в виртуальном пространстве ядра и добавляет этот новый большой кусок памяти в список свободных блоков.

## 5.4. Защита памяти

Защита памяти обеспечивается на аппаратном уровне процессором, а настраивается через VMM.

- **Изоляция процессов:** Каждый процесс имеет собственную PML4-таблицу, поэтому он не может получить доступ к данным других процессов. Все его виртуальные адреса в конечном итоге ссылаются на физические страницы, выделенные ему PMM'ом.
- **Защита ядра от пользовательского пространства:** В записях таблиц страниц, описывающих память ядра, установлен флаг `Supervisor`. Попытка доступа к этим страницам из пользовательского пространства (Ring 3) вызовет исключение General Protection Fault.
- **Защита от записи и выполнения:** Для каждой страницы можно установить флаги:
    - **`PAGE_WRITE`:** Определяет, разрешена ли запись в страницу. Код программы обычно находится на страницах "только для чтения".
    - **`PAGE_NO_EXEC` (NX Bit):** Запрещает выполнение кода со страниц, помеченных этим флагом (например, со стека или кучи), что является важной мерой безопасности против атак типа "buffer overflow".