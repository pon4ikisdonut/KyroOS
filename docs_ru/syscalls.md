# 7. Системные вызовы

Системные вызовы (syscalls) — это основной интерфейс, через который приложения пользовательского пространства (Ring 3) запрашивают у ядра выполнение привилегированных операций, таких как работа с файлами, управление памятью или взаимодействие с устройствами.

## 7.1. Механизм системных вызовов

Механизм системных вызовов в KyroOS использует программное прерывание.

1.  **Инициация:** Пользовательское приложение загружает номер системного вызова и его аргументы в регистры согласно ABI, после чего выполняет инструкцию `int 0x80`.
2.  **Переход в ядро:** Процессор генерирует прерывание с вектором 128 (0x80). Это вызывает переключение с Ring 3 на Ring 0 и передачу управления обработчику прерываний ядра.
3.  **Низкоуровневый обработчик (`isr128`):** Ассемблерная заглушка, ассоциированная с вектором 128, выполняет следующие действия:
    *   Сохраняет полный контекст регистров пользовательского потока на его стеке ядра.
    *   Вызывает высокоуровневый C-диспетчер `syscall_handler()`, передавая ему указатель на сохраненные регистры.
4.  **Диспетчер (`syscall_handler`):**
    *   Извлекает номер системного вызова из сохраненного регистра `rax`.
    *   Использует этот номер как индекс в глобальной таблице `syscall_table` для поиска адреса функции, реализующей данный syscall.
    *   Если обработчик найден, он вызывается. Ему также передается указатель на `struct registers`.
5.  **Выполнение:** Конкретный обработчик (например, `sys_write`) извлекает свои аргументы из сохраненных регистров (`rdi`, `rsi` и т.д.), выполняет необходимую работу и записывает результат (возвращаемое значение) обратно в поле `rax` в структуре `registers` на стеке.
6.  **Возврат в пользовательское пространство:** После завершения работы C-обработчиков управление возвращается в `isr128`. Он восстанавливает все регистры из `struct registers` и выполняет инструкцию `iretq`. Эта инструкция атомарно возвращает управление в пользовательское приложение, восстанавливая его регистры (включая `rax` с результатом) и переключая процессор обратно в Ring 3.

## 7.2. ABI (Application Binary Interface)

Соглашение о вызовах (Calling Convention) для системных вызовов в KyroOS основано на стандарте System V AMD64 ABI.

| Регистр | Назначение                    |
| :------ | :---------------------------- |
| `rax`   | Номер системного вызова (вход), Возвращаемое значение (выход) |
| `rdi`   | 1-й аргумент                  |
| `rsi`   | 2-й аргумент                  |
| `rdx`   | 3-й аргумент                  |
| `r10`   | 4-й аргумент                  |
| `r8`    | 5-й аргумент                  |
| `r9`    | 6-й аргумент                  |

Отрицательное значение в `rax` после вызова обычно сигнализирует об ошибке.

## 7.3. Таблица системных вызовов

В ядре (`src/kernel/syscall.c`) определена статическая таблица `syscall_table` — массив из 256 указателей на функции.

```c
static void (*syscall_table[256])(struct registers *regs);
```

Функция `syscall_init()` заполняет эту таблицу, сопоставляя номера вызовов (макросы `SYS_*` из `src/include/syscall.h`) с их C-реализациями. Если приложение запрашивает несуществующий syscall, диспетчер не находит обработчика в таблице и просто возвращает управление, не производя никаких действий.

### Основные системные вызовы:

| Номер | Имя                  | Описание                                           |
| :---- | :------------------- | :------------------------------------------------- |
| 0     | `SYS_EXIT`           | Завершить текущий поток.                           |
| 1     | `SYS_WRITE`          | Записать данные в файл или стандартный вывод.      |
| 2     | `SYS_OPEN`           | Открыть или создать файл.                          |
| 3     | `SYS_CLOSE`          | Закрыть файловый дескриптор.                       |
| 4     | `SYS_READ`           | Прочитать данные из файла.                         |
| 5     | `SYS_STAT`           | Получить информацию о файле.                       |
| 6     | `SYS_MKDIR`          | Создать директорию.                                |
| 10    | `SYS_SOCKET`         | Создать конечную точку для коммуникации (сокет).   |
| 17    | `SYS_GET_TICKS`      | Получить количество тиков системного таймера.      |
| 24    | `SYS_EXEC`           | Загрузить и выполнить программу (упрощенная версия).|
| 25    | `SYS_GFX_GET_FB_INFO`| Получить информацию о framebuffer.                 |
| 26    | `SYS_INPUT_POLL_EVENT`| Опросить очередь событий ввода.                  |

*(Полный список см. в `src/include/syscall.h`)*

## 7.4. Примеры использования (C-like)

Так как системные вызовы выполняются через ассемблерные инструкции, в стандартной библиотеке пользовательского пространства (`libc`) создаются функции-обертки.

**Пример 1: Вывод строки "Hello, World!" на стандартный вывод (stdout = 1).**

```c
// Код в userspace/lib/libc/stdio.c (пример)
#include <unistd.h>
#include <string.h>

void puts(const char* str) {
    // SYS_WRITE = 1
    // 1-й аргумент (fd) = 1 (stdout)
    // 2-й аргумент (buf) = str
    // 3-й аргумент (size) = strlen(str)
    syscall(SYS_WRITE, 1, str, strlen(str));
    syscall(SYS_WRITE, 1, "\n", 1); // Добавить перевод строки
}

// Код в приложении
int main() {
    puts("Hello, World!");
    return 0;
}
```
Здесь `syscall()` — это ассемблерная функция-обертка, которая загружает аргументы в регистры и выполняет `int 0x80`.

**Пример 2: Получение текущего времени в тиках.**
```c
// Код в userspace/lib/libc/time.c (пример)
uint64_t get_ticks() {
    // SYS_GET_TICKS = 17. Аргументов нет.
    return syscall(SYS_GET_TICKS);
}
```
Здесь `syscall(SYS_GET_TICKS)` загрузит `17` в `rax`, выполнит `int 0x80`, и после возвращения из ядра вернет значение, которое ядро положило в `rax`.

